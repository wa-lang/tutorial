{
  "en": {
    "title": "en",
    "path": "en",
    "children": {
      "1.InstallAndGetStart": {
        "title": "1.InstallAndGetStart",
        "path": "en/1.InstallAndGetStart",
        "children": {
          "1.1.HelloWorld": {
            "title": "1.1.HelloWorld",
            "path": "en/1.InstallAndGetStart/1.1.HelloWorld.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 1.1. hello world\n\nPrinting \"hello world\" is a common example for PL. The Wa-lang example prints \"你好，凹语言！\" in Chinese, means \"Hello, Wa-lang\".\n\n### 1.1.1 你好，凹语言！\n\nCreate hello.wa file with the following content:\n\n```wa\n// 版权 @2019 凹语言 作者。保留所有权利。\n\nimport \"fmt\"\nimport \"runtime\"\n\nglobal year: i32 = 2023\n\nfunc main {\n    println(\"你好，凹语言！\", runtime.WAOS)\n    println(add(40, 2), year)\n\n    fmt.Println(\"1+1 =\", 1+1)\n}\n\nfunc add(a: i32, b: i32) => i32 {\n    return a+b\n}\n```\n\nAmong them, `//` starts with a line comment, the `import` keyword imports two packages of the standard library, and the `global` keyword defines a global variable and gives an initial value of 2023. The `func` keyword defines the `main` function and the `add` function. The `main` function is the entry point of the program, which prints \"你好，凹语言！\" through the built-in `println` function, while using the `Println` string and integer expression results of the `fmt` package. The global `year` variable is also used in the `main` function. In addition, the `add` function is called and the return value is printed. The `add` function has 2 input parameters and a return value.\n\nIf the `wa` command of the Wa-lang has been installed locally (refer to Section 1.2 for the installation), you can enter the following command to execute:\n\n``` zsh\n$ wa run hello.wa\n你好，凹语言！ wasi\n42\n1+1 = 2\n```\n\n### 1.1.2 Playground online\n\nThe Wa-lang is a general-purpose programming language designed for WebAssembly. From its inception, the browser has been the first support target. Playground can be accessed through [https://wa-lang.org/playground](https://wa-lang.org/playground). The interface is as follows:\n\nKnown issues:\n- The online playground only supports single file mode and does not support multi-file project mode yet. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.\n",
            "code": "import \"fmt\"\nimport \"runtime\"\n\nglobal year: i32 = 2023\n\nfunc main {\n\tprintln(\"Hello Wa Lang\", runtime.WAOS)\n\tprintln(add(40, 2), year)\n\n\tfmt.Println(\"1+1 =\", 1+1)\n}\n\nfunc add(a: i32, b: i32) => i32 {\n\treturn a + b\n}\n"
          },
          "1.2.Install": {
            "title": "1.2.Install",
            "path": "en/1.InstallAndGetStart/1.2.Install.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 1.2. Install Wa-lang Compiler\n\nIn addition to accessing the online Wa-lang playground, you can also install the compiler locally.\n\n### 1.2.1 Install binaries\n\nDownload the latest binaries from Github: [https://github.com/wa-lang/wa/releases](https://github.com/wa-lang/wa/releases). You need to ensure that it corresponds to the local platform. For example, on macOS/amd64, [wa_0.8.1_darwin_amd64.tar.gz](https://github.com/wa-lang/wa/releases/download/v0.8.1/wa_0.8.1_darwin_amd64.tar.gz) should be used.\n\nThe contents of the directory after decompression are as follows:\n\n``` zsh\n$ tree ./wa_0.8.1_darwin_amd64\n./wa_0.8.1_darwin_amd64\n├── LICENSE\n├── README-zh.md\n├── README.md\n└── wa\n\n1 directory, 5 files\n```\n\nAdd the directory path to the system's `PATH` environment, then reopen the command line environment and execute the `wa -v` command to view the version information.\n\n``` zsh\n$ wa -v\nWa version v0.8.1\n```\n\nThe first time you execute the `wa` command, a `wa.wat2wasm.exe` command will be generated in the same directory as the command.\n\nThe installation is now completed.\n\n### 1.2.2 Install from source code\n\nInstalling from source requires installing Go1.17+ version, then execute the following command to install the latest Wa-lang compiler:\n\n``` zsh\ngo install wa-lang.org/wa\n```\n\nIt will be installed to the `$HOME/go/bin` directory by default, so this directory path needs to be added to the system's `PATH` environment.\nThen reopen the command line environment and execute the `wa` command once, the same help information as above will be output.\n\nThe first time you execute the `wa -v` command to view version information, a `wa.wat2wasm.exe` command will be generated in the same directory as the command.\n\nThe installation work is now completed.\n\n### 1.2.3 Homebrew (MacOS & Linux)\n\nFor macOS and Linux systems, it can also be installed through Homebrew:\n\n``` zsh\nbrew install wa-lang/tap/wa\n```\n\n### 1.2.4 Scoop (Windows)\n\nFor Windows systems, it can also be installed through Scoop:\n\n``` zsh\nscoop bucket add wa-lang https://github.com/wa-lang/scoop-bucket.git\nscoop install wa-lang/wa\n```\n\n### 1.2.5 local Playground\n\nAfter the Wa-lang compiler is successfully installed, enter `wa play` on the command line to open the local playground. The program will open the browser page by default, or you can enter the [http://localhost:2023/](http://localhost:2023/) address to access.\n"
          },
          "1.3.Command": {
            "title": "1.3.Command",
            "path": "en/1.InstallAndGetStart/1.3.Command.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 1.3. wa command line\n\nThis section introduces the main functions of the `wa` command.\n\n### 1.3.1. Help message\n\nEnter the `wa` command or `wa -h` to view command line help information, as follows:\n\n``` zsh\n$ wa\nNAME:\n   Wa - Wa is a tool for managing Wa source code.\n\nUSAGE:\n   wa [global options] command [command options] [arguments...]\n\nVERSION:\n   v0.8.1-mvp\n\nCOMMANDS:\n   play   start Wa playground\n   init   init a sketch Wa module\n   build  compile Wa source code\n   run    compile and run Wa program\n   fmt    format Wa source code file\n   test   test Wa packages\n   yacc   generates parsers for LALR(1) grammars\n   logo   print Wa text format logo\n\nGLOBAL OPTIONS:\n   --debug, -d              set debug mode (default: false)\n   --trace value, -t value  set trace mode (*|app|compiler|loader)\n   --help, -h               show help (default: false)\n   --version, -v            print the version (default: false)\n\nCOPYRIGHT:\n   Copyright 2018 The Wa Authors. All rights reserved.\n\nSee \"https://wa-lang.org\" for more information.\n```\n\nIt has the following subcommands:\n\n- play：Start the local version of the playground；\n- init: initialize a Wa-lang project;\n- build: compile Wa-lang program;\n- run: compile and execute the Wa-lang program;\n- fmt: format the Wa-lang source code file;\n- test: execute the unit test of the Wa-lang project;\n- yacc: The W-lang version of yacc, used to generate parser code for LALR(1) grammar rules;\n- logo: Print the logo in Wa-lang and text version.\n\nThe build command has been shown in Section 1.1.1, and the play command has been shown in Section 1.2.5. This section briefly introduces other subcommands.\n\n### 1.3.2 Initialize project\n\nIn Section 1.1.1 we have shown that `wa run hello.wa` executes a Wa-lang program in a separate file. But a single-file Wa-lang program has a huge limitation - it has only one file and cannot reference non-standard library code. For larger Wa-lang it is recommended to organize them in project mode.\n\nUse the `wa init` command to initialize a Wa project. Take a look at the command line help first:\n\n``` zsh\n$ wa init -h\nNAME:\n   wa init - init a sketch Wa module\n\nUSAGE:\n   wa init [command options] [arguments...]\n\nOPTIONS:\n   --name value, -n value     set app name (default: \"hello\")\n   --pkgpath value, -p value  set pkgpath file (default: \"myapp\")\n   --update, -u               update example (default: false)\n   --help, -h                 show help (default: false)\n```\n\nThis command has two important parameters, `-name` and `-pkgpath`, which correspond to the name of the project and the corresponding package path respectively. Each parameter has a default value, and you can use `wa init` to generate a hello project.\n\n``` zsh\n$ wa init\n$ tree hello\nhello\n├── LICENSE\n├── README.md\n├── src\n│   ├── main.wa\n│   ├── mymath\n│   │   └── math.wa\n│   ├── mypkg\n│   │   └── pkg.wa\n│   └── zz_test.wa\n├── vendor\n│   └── 3rdparty\n│       └── pkg\n│           └── pkg.wa\n└── wa.mod\n\n7 directories, 8 files\n```\n\nThe structure of the project will be introduced in Section 1.4.\n\n### 1.3.3 Compile and execute\n\nEnter the hello directory in the command line environment and enter `wa build` to build the wasm module in the output directory:\n\n``` zsh\n$ wa build\n$ tree output/\noutput/\n├── hello.wasm\n└── hello.wat\n\n1 directory, 2 files\n```\n\nThe default output is the WASI specificated `output/hello.wat` and `output/hello.wasm` files. The exported wasm module can be executed with standard tools. You can also use the `wa` command to execute:\n\n``` zsh\n$ wa run ./output/hello.wasm\n你好，凹语言！\n5050\n...\n```\n\nIf you execute the `wa run` command without entry, it means that the current Wa-lang project will be compiled and executed. `output/hello.wasm` will be built first and then executed.\n\n### 1.3.4 Format code\n\nThe `wa fmt` command is used to format code, and its command line help information is as follows:\n\n``` zsh\n$ wa fmt -h\nNAME:\n   wa fmt - format Wa source code file\n\nUSAGE:\n   wa fmt [command options] [<file.wa>|<path>|<path>/...]\n\nOPTIONS:\n   --help, -h  show help (default: false)\n```\n\nThe command line argument is the path to be formatted:\n\n- `wa fmt file.wa` formats the specified .wa file\n- `wa fmt path` formats all .wa files in the specified directory\n- `wa fmt path/...` recursively formats the .wa file in the specified path, including subdirectories\n\nIf no parameters are specified, all .wa files in the current directory will be formatted by default. If the current directory belongs to the Wa-lang project, the .wa files in all subdirectories will be formatted by default.\n\n### 1.3.5 Unit test\n\nThe project generated by default will have a `src/zz_test.wa` test file with the following content:\n\n```wa\nfunc TestSum {\n    assert(sum(100) == 5050, \"sum(100) failed\")\n}\n\nfunc ExampleSum {\n    println(sum(100))\n\n    // Output:\n    // 5050\n}\n```\n\nThe result of testing `sum(100)` in the `TestSum` test function via the built-in `assert` function is 5050. In the `ExampleSum` example test function, pass `//Output:` to test that the output meets the expected results.\n\nExecute the test through the `wa test` command in the command line environment of the project directory:\n\n``` zsh\n$ wa test\nok   myapp 104ms\n```\n\n### 1.3.6 Wa-lang version of yacc\n\nyacc is a program for generating syntax parsers, a tool for compiler enthusiasts. The yacc of the Wa-lang language is transplanted from goyacc. For detailed usage, please refer to the [related articles](https://wa-lang.org/smalltalk/st0021.html) in the SmallTalk section of the wa-lang official website .\n\n### 1.3.7 Print Logo\n\n`wa logo` can output some logo patterns in text format, and readers can explore by themselves through the `wa logo -h` command.\n"
          },
          "1.4.ProjectStructure": {
            "title": "1.4.ProjectStructure",
            "path": "en/1.InstallAndGetStart/1.4.ProjectStructure.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 1.4. Project directory structure\n\nThe project directory structure is the basis for the work of the entire peripheral tools. For example, init generates projects based on this structure, and the package management tool manages dependencies in turn.\n\n### 1.4.1 Project directory structure\n\nWa-lang programs organize code in packages. A package can be a single file or a directory. The `waroot/examples/hello` case that comes with Wa-lang is a more complete project, and its directory structure is as follows:\n\n``` zsh\nexamples/hello/\n├── LICENSE\n├── README.md\n├── src\n│   ├── main.wa\n│   └── mymath\n│       └── math.wa\n├── vendor\n│   └── 3rdparty\n│       └── pkg\n│           └── pkg.wa\n└── wa.mod\n```\n\nIn addition to copyright files and description files, the most important thing is the `wa.mod` package project file, which defines the package path of the current application. In addition, the code in the src directory is the code under the current package path, which is the default main entry package.\n\nThe contents of the `wa.mod` file are as follows:\n\n``` zsh\nname = \"hello\"\npkgpath = \"myapp\"\nversion = \"0.0.1\"\n```\n\nAmong them, pkgpath represents the path of the current package, so it can be deduced that the package path corresponding to the mymath subdirectory is `\"myapp/mymath\"`. The vendor directory is the dependent third-party code, where the package path corresponding to `vendor/3rdparty/pkg` is `\"3rdparty/pkg\"`.\n\n### 1.4.2 Package management tool\n\nWa-lang currently does not have a package management tool. If you rely on third-party packages, you need to manually synchronize the vendor directory. The development team hopes to start developing package management tool after the MVP version.\n"
          },
          "1.5.Plugins": {
            "title": "1.5.Plugins",
            "path": "en/1.InstallAndGetStart/1.5.Plugins.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 1.5. Plug-ins for IDE\n\nModern programming languages generally provide extensions for various IDEs and editors to improve the programming experience. The Wa-lang provides basic plug-in support for VS Code, Fleet and Vim.\n\n### 1.5.1 Plug-in for VSCode\n\nSearch for \"wa\" in the VS Code extension store to find the Wa-lang plugin. After installation, there will be basic syntax highlighting and other functions.\n\n### 1.5.2 Plug-in for Fleet\n\nRepository: [https://github.com/wa-lang/fleet-wa](https://github.com/wa-lang/fleet-wa)\n\n### 1.5.3 Plug-in for Vim\n\nVim plug-in repository: [https://github.com/wa-lang/vim-wa](https://github.com/wa-lang/vim-wa)\n\n### 1.5.4 Other Plug-ins\n\nAfter the MVP, the syntax of the Wa-lang has been stablized, and we hope that the community can participate in the co-construction of other editors to support it.\n"
          },
          "readme": {
            "title": "1. Install and get start",
            "path": "en/1.InstallAndGetStart/readme.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: https://github.com/wa-lang/man/tree/master/en*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n# 1. Install and get start\n\nThis chapter describes the simplest Wa-lang example, how to install the Wa-lang compiler, plug-ins for IDE, project directory structure and command line functions, etc.\n"
          }
        }
      },
      "2.ProgramStructure": {
        "title": "2.ProgramStructure",
        "path": "en/2.ProgramStructure",
        "children": {
          "2.1.GlobalDeclaration": {
            "title": "2.1.GlobalDeclaration",
            "path": "en/2.ProgramStructure/2.1.GlobalDeclaration.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 2.1. Global declaration\n\nA typical Wa-lang program source code is as follows:\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nimport \"errors\"\n\nconst PI = 3.1415926\n\nglobal 终极问题的答案: i32\n\nfunc main {\n    终极问题的答案 = getAnswer()\n    println(\"宇宙的答案：\", 终极问题的答案)\n    println(\"π:\", PI)\n\n    err := errors.New(\"!!!\")\n    println(\"err:\", err.Error())\n}\n\nfunc getAnswer => i32 {\n    return 42\n}\n```\n\n> Similar to many languages, in Wa-lang, the part from the double slash `//` to the end of the line is a comment and has no actual effect.\n\nWa code consists of `global declarations`, like in the example above:\n\n- `import \"errors\"` is a declaration that imports the `errors` module\n- `const PI = 3.1415926` is a constant declaration, which declares a constant named `PI` with the value 3.1415926\n- `global The answer to the ultimate question: i32` is a global variable declaration, which declares a global variable named `The answer to the ultimate question`, of type 32-bit integer\n- `func getAnswer => i32 {...}` is a function declaration that declares a function that returns a 32-bit integer\n\nThere are 5 global declarations in Wa-lang. Each declaration starts with a specific keyword (followed by the entity of the declaration object). The relationship between the declaration and the corresponding keywords is as follows:\n\n- `global`: global variable declaration\n- `func`: function declaration\n- `const`: constant declaration\n- `import`: import declaration\n- `type`: type declaration\n\nThe following sections of this chapter will introduce global variable declarations, function declarations, constant declarations, and import declarations in sequence. Type declarations will be explained separately in Chapter 6.\n",
            "code": "import \"errors\"\n\nconst PI = 3.1415926\n\nglobal answer: i32\n\nfunc main {\n\tanswer = getAnswer()\n\tprintln(\"The Answer to the Universe:\", answer)\n\tprintln(\"π:\", PI)\n\n\terr := errors.New(\"!!!\")\n\tprintln(\"err:\", err.Error())\n}\n\nfunc getAnswer => i32 {\n\treturn 42\n}\n"
          },
          "2.2.GlobalVariableDeclaration": {
            "title": "2.2.GlobalVariableDeclaration",
            "path": "en/2.ProgramStructure/2.2.GlobalVariableDeclaration.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 2.2. Global variable declaration\n\nGlobal variable declaration starts with the keyword `global`, and the general syntax is as follows:\n\n```wa\nglobal VarName: Type = initial value expression\n```\n\nFor example:\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nglobal aInt: i32 = 42     // 32-bit signed integer\nglobal _num: f32 = 952.7  // 32-bit floating point number\n\nfunc main {\n    println(aInt)\n    println(_num)\n    println(名字)\n    println(counter)\n}\n\nglobal 名字: string = \"张三\" // string\nglobal counter: u32         // 32-bit unsigned integer\n```\n\nThe output of this program is as follows:\n\n```\n42\n952.7\n张三\n0\n```\n\nGlobal variables can be used anywhere inside the module - even if the declaration and use of global variables are in different source files, as long as they are in the same module; in the source file, there is no need to \"declare first and then use\". In the above example, the variables `name` and `counter` can reflect this feature.\n\nIt should be noted that the variable `counter` in the above example is declared without an initial value:\n> In Wa-lang, variables that are not given an initial value are always initialized with a value of 0, which helps eliminate uncertainty.\n",
            "code": "global aInt: i32 = 42\nglobal _num: f32 = 952.7\nglobal name: string = \"Tom\"\nglobal counter: u32\n\nfunc main {\n\tprintln(aInt)\n\tprintln(_num)\n\tprintln(name)\n\tprintln(counter)\n}\n"
          },
          "2.3.FunctionDeclaration": {
            "title": "2.3.FunctionDeclaration",
            "path": "en/2.ProgramStructure/2.3.FunctionDeclaration.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 2.3. Function declaration\n\nThe function declaration starts with the keyword `func`, and the general syntax is as follows:\n\n```wa\nfunc FunctionName (parameter list) => (return value list) {function body}\n```\n\nFor example：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc swap(i, j: i32) => (i32, i32) {\n    return j, i\n}\n\nfunc main {\n    a, b := swap(4, 2)\n    println(\"a:\", a, \", b:\", b)\n    println(add(a, b))\n}\n\nfunc add(i, j: i32) => i32 {\n    return i + j\n}\n```\n\nThe output of this program is as follows:\n\n``` zsh\na: 2 , b: 4\n6\n```\n\nFor functions without return values, the `=> (return value list)` part can be omitted, and for functions without input parameters, the `(parameter list)` part can be omitted, such as in the above example: `func main {... }`, which is the abbreviation of: `func main() => () {...}`.\n\nLike global variables, functions can be declared in any source file within a package and do not require \"declare before use\".\n\nSee Chapter 4 for more information about functions.\n",
            "code": "func swap(i, j: i32) => (i32, i32) {\n\treturn j, i\n}\n\nfunc main {\n\ta, b := swap(4, 2)\n\tprintln(\"a:\", a, \", b:\", b)\n\tprintln(add(a, b))\n}\n\nfunc add(i, j: i32) => i32 {\n\treturn i + j\n}\n"
          },
          "2.4.ConstDeclaration": {
            "title": "2.4.ConstDeclaration",
            "path": "en/2.ProgramStructure/2.4.ConstDeclaration.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 2.4. Constant declaration\n\nThe constant declaration starts with the keyword `const`, and the general syntax is as follows:\n\n```wa\nconst 常量名: 类型 = 常量值\n```\n\nFor example:\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nconst Answer: i32 = 42\nconst aConstString: string = \"你好，凹语言\"\n\nfunc main {\n    println(Answer)\n    println(aConstString)\n    println(aConstInt)\n}\n\nconst aConstInt = 13\n```\n\nThe output of this program is as follows:\n\n```\n42\n你好，凹语言\n13\n```\n\nWhen declaring a constant, if you do not specify a type (such as `aConstInt` in the above example), then it will be an **untyped constant**. There are 4 types of untyped constants: `untyped integer`, `untyped floating point number`, `untyped characters`, `untyped strings`, respectively:\n\n```wa\nconst aUntypedInt = 11       // untyped integer\nconst aUntypedFloat = 13.0   // untyped floating point number\nconst aUntypedRune = 'a'     // untyped characters\nconst aUntypedString = \"abc\" // untyped strings\n```\n\nArithmetic and logical operations on constant values are completed at compile time, such as:\n\n```wa\n// 版权 @2019 凹语言 作者。保留所有权利。\n\nconst K = 4200000000000000000000000\nconst J = 4200000000000000000000000\n\nfunc main {\n    println(K/J)\n}\n```\n\nAlthough the values of `K` and `J` both exceed the expression range of `i64`(the largest type in Wa-lang), the value of `K/J` can still be printed correctly. This also reflects that **numeric constants have an expression range and precision that exceeds the basic type of variables**.\n\nThe relevant rules when assigning constants to variables will be discussed in detail in Chapter 3.\n",
            "code": "const Answer: i32 = 42\nconst aConstString: string = \"Hello Wa\"\nconst aConstInt = 13\nconst K = 4200000000000000000000000\nconst J = 4200000000000000000000000\n\nconst aUntypedInt = 11\nconst aUntypedFloat = 13.0\nconst aUntypedRune = 'a'\nconst aUntypedString = \"abc\"\n\nfunc main {\n\tprintln(Answer)\n\tprintln(aConstString)\n\tprintln(aConstInt)\n\tprintln(K / J)\n}\n"
          },
          "2.5.ImportDeclaration": {
            "title": "2.5.ImportDeclaration",
            "path": "en/2.ProgramStructure/2.5.ImportDeclaration.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 2.5. Import declaration\n\nThe import declaration starts with the keyword `import`, and the general syntax is as follows:\n\n```wa\nimport path\n```\n\nFor example：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nimport \"errors\"\n\nfunc main {\n    err := errors.New(\"!!!\")\n    println(\"err:\", err.Error())\n}\n\nfunc getAnswer => i32 {\n    return 42\n}\n```\n\nThe `import \"errors\"` declaration at the beginning of the program imports the built-in `errors` module, and the public objects of this module can be used in subsequent functions - such as the `errors.New` function in the example; `.` in It is called the **selection operator** here. Its meaning is to select the object (module) on the left with the same name as the one on the right. In addition to selecting functions and global functions exposed by the module, Objects such as variables are also used to select members of structures (see Chapter 6 for details).\n\nImport declarations should precede all non-import declarations within the source file (i.e., in the header, immediately after the file header comment). If you import multiple modules, you can use brackets to import them in groups, like this:\n\n```wa\nimport (\n    \"errors\"\n    \"strconv\"\n)\n```\n\nThis is equivalent to the following:\n\n```wa\nimport \"errors\"\nimport \"strconv\"\n```\n\nWhen importing a module, you can give the module an alias. The general syntax is as follows:\n\n```wa\nimport path => alias\n```\n\nThis can solve the problem of name conflict when importing two modules with different paths but the same name at the same time, for example:\n\n```wa\nimport (\n    \"errors\"\n    \"mypackage/errors\" => myerrors\n)\n\nfunc main {\n    err := errors.New(\"!!!\")     // Call the built-in errors module\n    myerr := myerrors.New(\"!!!\") // Call the mypackage/errors module块\n}\n```\n\n> Unlike other declarations, the scope of the **import declaration is the current source file**. If two source files in a module use the same third-party module, then their import declarations are required in both files.\n\nIn Wa-lang, every module imported by a source file must be used, that is, if a module is imported but none of its objects are used, it will be considered a syntax error.\n",
            "code": "import (\n\t\"errors\"\n)\n\nfunc main {\n\terr := errors.New(\"!!!\")\n\tprintln(\"err:\", err.Error())\n}\n"
          },
          "readme": {
            "title": "2. Program structure",
            "path": "en/2.ProgramStructure/readme.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n# 2. Program structure\n\nLike other programming languages, a Wa-lang program is composed of many small parts. This chapter introduces global variable declarations, function declarations, constant declarations, import declarations, and type declarations.\n"
          }
        }
      },
      "3.BasicTypes": {
        "title": "3.BasicTypes",
        "path": "en/3.BasicTypes",
        "children": {
          "3.1.LocalVariableDeclaration": {
            "title": "3.1.LocalVariableDeclaration",
            "path": "en/3.BasicTypes/3.1.LocalVariableDeclaration.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 3.1. Local variable declaration\n\nChapter 2 introduces global variable and constant declarations. Also commonly used is local variable (variables defined within a function) declaration. Its general syntax is:\n\n```wa\nVarName: Type = initial Value\n```\n\nWhat is different from all variables and constants is that the declaration of local variables does not start with a keyword; when declaring a local variable, if the `= initial value` part is omitted, the variable will be initialized with a value of 0, such as:\n\n```wa\naI32: i32 = 42\naString: string = \"你好\"\naF32: f32  // 0.0\n```\n\nAnother commonly used syntax for declaring local variables uses the short-declaration `:=`. The syntax is as follows:\n\n```wa\nVarName := expression\n```\n\nWhen using this writing method, the type of the variable will be consistent with the type of the expression on the right side of the short-declaration, and the value of the expression will be assigned to the initial value of the local variable, such as:\n\n```wa\na := 13          // int\nf := 3.14        // f64\ns := genString() // string\n...\nfunc genString() => string { return \"Hello\" }\n```\n\n> Wa-lang is a statically typed language. The type of a legal expressions can be inferred at compile time, so the type of a expression is determined. The `:=` syntax is similar to C++'s `auto` type.\n",
            "code": "func main() {\n\taI32: i32 = 42\n\taString: string = \"Hello Wa\"\n\taF32: f32\n\n\ta := 13\n\tf := 3.14\n\ts := genString()\n\n\tprintln(aI32)\n\tprintln(aString)\n\tprintln(aF32)\n\tprintln(a)\n\tprintln(f)\n\tprintln(s)\n}\n\nfunc genString() => string {\n\treturn \"Hello\"\n}\n"
          },
          "3.2.Integers": {
            "title": "3.2.Integers",
            "path": "en/3.BasicTypes/3.2.Integers.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 3.2. Integers\n\nWa-lang currently supports the following integer types:\n\n- `u8`: unsigned 8-bit integer;\n- `u16`: unsigned 16-bit integer;\n- `i32`: signed 32-bit integer;\n- `u32`: unsigned 32-bit integer;\n- `i64`: signed 64-bit integer;\n- `u64`: unsigned 64-bit integer;\n- `int`: signed integer;\n- `uint`: unsigned integer;\n- `bool`: Boolean type.\n\nAmong them:\n- `int` and `uint` are variable-width integers, and their width is determined by the target platform. The reason why there are variable-width integer types is that the addressing range of the target platform may be different. Operations involving the storage range such as the built-in function `len` require a unified data type to ensure that the code can be compiled normally on different target platforms. And make full use of the platform addressing range;\n- The actual memory layout of `bool` type is `u8`, the literal values of legal values are `true`, `false`, and the corresponding memory values ​​are 1 and 0.\n\n> The current main target platform of Wa-lang is **wasm32**. Under this platform, the bit width of variable-width integers is 32 bits, which is 4 bytes.\n\nIntegers other than Boolean support the following unary operations:\n- `^`: bitwise negation\n- `-`: Take the negative arithmetic value (that is, subtract the operand from 0)\n\nFor example：\n```wa\ni: u8 = 9\nprintln(^i) // 246\nprintln(-i) // 247\n\nj: i32 = 9\nprintln(^i) // -10\nprintln(-i) // -9\n```\n\nIntegers other than Boolean support the following binary arithmetic operations:\n- `+`: Add, the two operand types must be consistent, the type of return value is same with operands;\n- `-`: Minus, the two operand types must be consistent, the type of return value is same with operands;\n- `*`: Mul, the two operand types must be consistent, the type of return value is same with operands;\n- `/`: Div, the two operand types must be consistent, the type of return value is same with operands;\n- `%`: Rem, the two operand types must be consistent, the type of return value is same with operands;\n\nFor example：\n```wa\ni, j: u8 = 9, 250\nprintln(i + j) // 3\nprintln(i - j) // 15\nprintln(i * j) // 202\nprintln(j / i) // 27\nprintln(j % i) // 7\n```\n\nIntegers(except Boolean) support the following binary bit operations:\n- `&`: bitwise AND, the two operand types must be consistent, the type of return value is same with operands;\n- `|`: Bitwise OR, the two operand types must be consistent, the type of return value is same with operands;\n- `^`: Bitwise XOR, the two operand types must be consistent, the type of return value is same with operands;\n- `&^`: clear bitwise, the two operand types must be consistent, the type of return value is same with operands. For `z = x &^ y`, let `xn`, `yn`, `zn` be the nth bit of `x`, `y`, `z` respectively, then when `yn` is 1, `zn ` is 0, otherwise `zn` is equal to `xn`. This operation is equivalent to `z = x & (^y)`;\n- `<<`: Left shift, for `z = x << y`, the type of `z` is consistent with `x`, `y` must be an integer greater than 0, and the low-order bit is filled with 0 when shifting;\n- `>>`: Right shift, for `z = x >> y`, the type of `z` is consistent with `x`, `y` must be an integer greater than 0, and the high bit is filled with 0 when shifting.\n\nFor example：\n```wa\ni, j: u16 = 343, 47831\nprintln(i & j)  // 87\nprintln(i | j)  // 48087\nprintln(i ^ j)  // 48000\nprintln(i &^ j) // 256\nprintln(i << 5) // 10976\nprintln(j >> 5) // 1494\n```\n\nThe results of operations such as addition, subtraction, multiplication, and left shift may exceed the expression range of the operands. In this case, the low-order part will be intercepted as the result.\n\nIntegers except Boolean support the following comparison operations:\n- `==`: equal. The operands types must be consistent, and the return value is of `bool` type. If the judgment condition is met, `true` will be returned, otherwise `false` will be returned, the same below;\n- `!=`: not equal;\n- `>`: greater than;\n- `>=`: greater than;\n- `<`: less than;\n- `<=`: Small equal to.\n> If one of the two operands involved in the comparison is a constant, the constant should be on the right side of the comparison operator.\n\nBoolean types support the following unary operations:\n- `!`: negation, if the operand is `false`, return `true`, otherwise return `false`.\n\nIn fact, in addition to the named constants declared through constants introduced in Section 2.4, many literal values appearing in the code are also constants, such as:\n```wa\ni := 13\n```\n\n`13` in the code is an untyped integer constant. When using untyped integer constants for variable short-declaration, the type of the variable is a variable-width signed integer (that is, `int`). The above code is equivalent to:\n```wa\ni: int\ni=13\n```\n\nWhen assigning an integer constant to an integer variable, type and range checking will be performed at compile time and automatically matched to the variable type - assigning a negative constant to an unsigned integer, or a constant value that exceeds the width of the assigned variable will be judged as illegal.\n\nIntegers support all binary operators, and binary operators have decreasing precedence in the following order (same precedence within the same line, executed from left to right):\n\n```\n*      /      %      <<       >>     &       &^\n+      -      |      ^\n==     !=     <      <=       >      >=\n&&\n||\n```\n",
            "code": "func main() {\n\ti: u8 = 9\n\tprintln(^i)\n\tprintln(-i)\n\n\tj: i32 = 9\n\tprintln(^j)\n\tprintln(-j)\n\n\tx, y: u8 = 9, 250\n\tprintln(x + y)\n\tprintln(x - y)\n\tprintln(x * y)\n\tprintln(y / x)\n\tprintln(y % x)\n\n\tm, n: u16 = 343, 47831\n\tprintln(m & n)\n\tprintln(m | n)\n\tprintln(m ^ n)\n\tprintln(m &^ n)\n\tprintln(m << 5)\n\tprintln(n >> 5)\n\n\tb1 := true\n\tb2 := false\n\tprintln(!b1)\n\tprintln(!b2)\n}\n"
          },
          "3.3.FloatingPointNumbers": {
            "title": "3.3.FloatingPointNumbers",
            "path": "en/3.BasicTypes/3.3.FloatingPointNumbers.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 3.3. Floating point number\n\nWa-lang currently supports the following types of floating point numbers (both are IEEE 754 standards):\n\n- `f32`: 32-bit floating point number\n- `f64`: 64-bit floating point number\n\nFloating point numbers support the following unary operators\n\n- `-`: Get the negative arithmetic value (that is, subtract the operand from 0)\n\nFor example：\n```wa\ni: f32 = 1.25\nprintln(-i) //-1.25\n```\n\nFloating point numbers support the following binary arithmetic operations:\n- `+`: Add, the two operand types must be consistent, the type of return value is same with operands;\n- `-`: Minus, the two operand types must be consistent, the type of return value is same with operands;\n- `*`: Mul, the two operand types must be consistent, the type of return value is same with operands;\n- `/`: Div, the two operand types must be consistent, the type of return value is same with operands;\n\nFor example：\n```wa\ni, j: f64 = 1, 0.5\nprintln(i + j) // 1.5\nprintln(i - j) // 0.5\nprintln(i * j) // 0.5\nprintln(j / i) // 2\n```\n\nFloating point numbers support the following comparison operations:\n- `==`: equal. The operands types must be consistent, and the return value is of `bool` type. If the judgment condition is met, `true` will be returned, otherwise `false` will be returned, the same below;\n- `!=`: not equal;\n- `>`: greater than;\n- `>=`: greater than;\n- `<`: less than;\n- `<=`: Small equal to.\n\nWhen using untyped floating-point constants for variable short-declaration, the variable type is `f64`. The following two ways of writing are equivalent:\n\n```wa\nf := 1.5\n```\n\n```wa\nf: f64 = 1.5\n```\n",
            "code": "func main() {\n\ti: f32 = 1.25\n\tprintln(-i)\n\n\tx, y: f64 = 1, 0.5\n\tprintln(x + y)\n\tprintln(x - y)\n\tprintln(x * y)\n\tprintln(y / x)\n\n\tf := 1.5\n\tprintln(f)\n}\n"
          },
          "3.4.String": {
            "title": "3.4.String",
            "path": "en/3.BasicTypes/3.4.String.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 3.4. String\n\nStrings are regarded as basic data types in Wa-lang. The type name is: `string`. String literal constants are defined by double quotes `\"\"` and are encoded in UTF-8, for example:\n\n```wa\ns: string = \"你好，凹语言\"\nprintln(s)     // 你好，凹语言\nprintln(\"+42\") // +42\n```\n\nSimilar to integers and floating point numbers, string variables can also be defined using short-declaration `:=`, for example:\n```wa\ns := \"编号9527\"\n```\n\nStrings support add (`+`) binary operations, and the return value is the concatenation of two strings, for example:\n\n```wa\ns1 := \"abc\"\ns2 := \"123\"\nprintln(s1 + s2) // abc123\n```\n\nThe underlying structure that holds a string is a byte (that is, `u8`) array. You can use `[]` to get the value of a certain byte, or a substring, for example:\n\n```wa\ns := \"abcdefg\"\nprintln(s[2])   // 99，the ASCII value of 'c'\nprintln(s[1:3]) // bc\n```\n\nIn this usage, the subscripted units within `[]` are bytes, not characters. If the source string contains non-ASCII characters (such as Chinese characters) and the subscript is not at an right boundary, the returned substring may be illegal, for example:\n```wa\ns := \"你好\"\nprintln(s[1:3]) // ��\n```\n\n`s[m:n]` operation starts from the `m`th byte, and the length of the returned string is `n-m` bytes. If `m` is omitted, it means start from the beginning of the string. If `n` is omitted, it means intercepting to the end of the string. For example:\n```wa\ns := \"abcdefg\"\nprintln(s[:3]) // abc\nprintln(s[3:]) // defg\n```\n\nFrom the perspective of the underlying data, when intercepting the substring, there is no re-alloc for a byte array copy, but a direct reference to the address of the original string. In order to avoid the impact of mutual modification of multiple strings referencing the same memory, the string is set so that it cannot be modified locally - neither can it be assigned to `s[n]`. The following example are illegal:\n```wa\ns := \"abcdefg\"\ns[0] = 99 // illegal\n```\n\nYou can use the `==` and `!=` operators to determine equality or inequality between two strings, for example:\n```wa\ns := \"abc\"\nprintln(s == \"123\") // false\nprintln(s != \"123\") // true\n```\n\nThe built-in function `len` can be used to get the length of a string in bytes, such as:\n\n```wa\ns := \"abcdefg\"\nprintln(len(s)) // 7\n```\n\nList of known issues:\n- Bounds checking was not performed when using `[]` to obtain the specified bytes or substring of a string variable. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.\n",
            "code": "func main() {\n\ts: string = \"Hello Wa\"\n\tprintln(s)\n\tprintln(\"+42\")\n\n\ts2 := \"Number 9527\"\n\tprintln(s2)\n\n\ts1 := \"abc\"\n\ts3 := \"123\"\n\tprintln(s1 + s3)\n\n\ts4 := \"abcdefg\"\n\tprintln(s4[2])\n\tprintln(s4[1:3])\n\tprintln(s4[:3])\n\tprintln(s4[3:])\n\n\tprintln(len(s4))\n\n\ts5 := \"abc\"\n\tprintln(s5 == \"123\")\n\tprintln(s5 != \"123\")\n}\n"
          },
          "readme": {
            "title": "3. Basic types",
            "path": "en/3.BasicTypes/readme.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n# 3. Basic types\n\nAt a low level, all data is made up of bits. The corresponding basic data types of Wa-lang include integers, floating point numbers, strings, etc. This chapter introduces basic data types and the use of local variables.\n"
          }
        }
      },
      "4.Function": {
        "title": "4.Function",
        "path": "en/4.Function",
        "children": {
          "4.1.FunctionCall": {
            "title": "4.1.FunctionCall",
            "path": "en/4.Function/4.1.FunctionCall.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 4.1. Function call\n\nWe have come across many functions in previous chapters, such as the commonly used built-in printing function `println`. The general syntax for function calls is:\n\n`FunctionName (actual parameter list)`\n\n`Actual parameters` refer to the parameters actually passed in when the function is called, corresponding to the `formal parameters` defined when the function is declared. The formal parameters are only valid within the function body. When calling a function in Wa-lang, parameters are passed by value. Changes to the formal parameter values within the function body will not affect the actual parameter values, for example:\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc Double(i: i32) => i32 {\n    i = i * 2\n    return i\n}\n\nfunc main {\n    j: i32 = 42\n    println(Double(j)) // 84\n    println(j)         // 42\n}\n```\n\nThe keyword `return` is used to exit the function and return values. The general syntax is:\n```wa\nreturn ValueList\n```\n\nIf a function has multiple return values, they should be separated by `,`, for example:\n\n```wa\nfunc MulRet() => (i32, i32) {\n    return 42, 13\n}\n```\n\nSimilar to formal parameters, named return values can be defined when a function is declared, for example:\n```wa\nfunc showAnswer() => (answer: i32) {\n    answer = 42\n    return\n}\n```\n\nThis is equivalent to:\n```wa\nfunc showAnswer() => i32 {\n    answer: i32\n    answer = 42\n    return answer\n}\n```\n\nLike other variables, named return values are initialized with a value of 0. If a function witch has many branches needs to return an error code, and most branch error codes have a value of 0, using a named return value can simplify the code.\n\nEven if a named return value is declared, `return` can still return other values, such as:\n```wa\n// 版权 @2019 凹语言 作者。保留所有权利。\n\nfunc showAnswer() => (answer: i32) {\n    answer = 13\n    return 42\n}\n\nfunc main {\n    println(showAnswer()) // 42\n}\n```\n\nSo we can understand it this way: the named return value actually defines a set of local variables in the function body. When the `return` statement within the function does not specify a return value, this set of local variables is automatically filled in as the return value.\n",
            "code": "func Double(i: i32) => i32 {\n\ti = i * 2\n\treturn i\n}\n\nfunc MulRet() => (i32, i32) {\n\treturn 42, 13\n}\n\nfunc showAnswer() => (answer: i32) {\n\tanswer = 42\n\treturn\n}\n\nfunc main {\n\tj: i32 = 42\n\tprintln(Double(j))\n\tprintln(j)\n\n\ta, b := MulRet()\n\tprintln(a, b)\n\n\tprintln(showAnswer())\n}\n"
          },
          "4.2.FunctionValues": {
            "title": "4.2.FunctionValues",
            "path": "en/4.Function/4.2.FunctionValues.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 4.2. Function values\n\nIn Wa-lang, functions can be treated as special values, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc Inc(i: i32) => i32 { return i + 1 }\nfunc Dec(i: i32) => i32 { return i - 1 }\n\nfunc main {\n    f := Inc\n    println(f(42)) // 43\n\n    f = Dec\n    println(f(42)) // 41\n}\n```\n\nIn the above example, `f` is the **function value**. The function value can be called, and the calling method is the same as the function call.\n\nThe type of a function is determined by its parameters and return value type. Usually this information is called **function signature** (Signature). If two functions A and B have the same signature, it means that they:\n- Their number of parameters is the same;\n- Their number of return values is the same;\n- For any n, the nth parameter of function A is of the same type as the nth parameter of B;\n- For any m, the mth return value of function A is of the same type as the mth return value of B.\n\nThe type of function value is also defined through function signature. For example, the type of function value `f` in the above example is `func(i32) => i32`, so the short-declaration of `f` in the above example is `f := Inc`, etc. Priced at:\n```wa\n    f: func(i32) => i32 // f == nil\n    f = Inc\n```\n\n> Like other types of values, function values are also initialized to 0, and the corresponding value is `nil`\n\nIn Wa-lang, values of different types cannot be assigned to each other. This is also valid for function values. Since the function type is determined by the signature, it is considered illegal to assign a function to a function value with different signatures. For example:\n```wa\nfunc Inc(i: i32) => i32 { return i + 1 }\n\nfunc main {\n    f: func(i32)\n    f = Inc // 编译错误\n}\n```\n\nSince it is called a \"value\", it means that function values can be passed between different functions as parameters and return values, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc inc(i: i32) => i32 { return i + 1 }\nfunc dec(i: i32) => i32 { return i - 1 }\nfunc getFunc(opCode: i32) => func(i32) => i32 {\n    if opCode == 0 {\n        return inc\n    } else if opCode == 1 {\n        return dec\n    } else {\n        return nil\n    }\n}\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n    if f == nil {\n        println(\"f == nil\")\n        return\n    }\n    println(f(i))\n}\n\nfunc main {\n    useFunc(42, getFunc(0)) // 43\n    useFunc(42, getFunc(1)) // 41\n    useFunc(42, getFunc(2)) // f == nil\n    getFunc(2)(42)          // 运行时异常\n}\n```\n\nUnlike other basic types, function values can only be compared with `nil`, that is: when the function value is on the left side of operators `==`, `!=`, the right side can only be `nil`, comparing two non-constants function value is considered illegal.\n\nIf the called function value is `nil`, an unrecoverable runtime exception will be triggered.\n\nFunction values are similar to function pointers in C language, and can dynamically adjust execution branches more flexibly. However, it needs to be pointed out that compared to calling the function directly, calling the function value has some additional consumption, and performance-sensitive occasions require special attention.\n",
            "code": "func inc(i: i32) => i32 { return i + 1 }\nfunc dec(i: i32) => i32 { return i - 1 }\n\nfunc getFunc(opCode: i32) => func(i32) => i32 {\n\tif opCode == 0 {\n\t\treturn inc\n\t} else if opCode == 1 {\n\t\treturn dec\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n\tif f == nil {\n\t\tprintln(\"f == nil\")\n\t\treturn\n\t}\n\tprintln(f(i))\n}\n\nfunc main {\n\tf := inc\n\tprintln(f(42))\n\tf = dec\n\tprintln(f(42))\n\n\tuseFunc(42, getFunc(0))\n\tuseFunc(42, getFunc(1))\n\tuseFunc(42, getFunc(2))\n}\n"
          },
          "4.3.AnonymousFunctionsAndClosures": {
            "title": "4.3.AnonymousFunctionsAndClosures",
            "path": "en/4.Function/4.3.AnonymousFunctionsAndClosures.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 4.3. Anonymous functions and closures\n\nThe previous section introduced the basic usage of function values. Since functions can be regarded as values, can function literals be declared inside functions in the same way as basic type literals? The answer is yes, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n    if f == nil {\n        println(\"f == nil\")\n        return\n    }\n    println(f(i))\n}\n\nfunc main {\n    f := func(i: i32) => i32 { return i * i } // Declare an anonymous function and assign it to f\n    useFunc(3, f) // 9\n}\n```\n\nAmong them, `f` is a function value, its initial value is the literal `func(i: i32) => i32 { return i * i }`, which is a function without a name. In Wa-lang, this kind of function literal without a name is called an anonymous function. In application scenarios such as visitor mode and custom quick sorting, it is often necessary to pass in some function value parameters, and these functions may only appear once. For this reason, it is inconvenient to define additional module-level global functions. You can use anonymous functions.\n\n**Anonymous function B declared inside function A can access local variables inside A**, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n    if f == nil {\n        println(\"f == nil\")\n        return\n    }\n    println(f(i))\n}\n\nfunc main {\n    n: i32 = 0\n    f := func(i: i32) => i32 {\n        n = i * i\n        return n\n    }\n    useFunc(3, f)\n    println(n) // 9\n}\n```\n\nObviously the function value `f` can read and write the outer local variable `n`. Let’s look at a more complex example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\nfunc genClosure(i: i32) => func() => i32 {\n    n := i\n    return func() => i32 {\n        n = n + 1\n        return n\n    }\n}\n\nfunc main {\n    c := genClosure(0)\n    d := genClosure(99)\n\n    println(c()) // 1\n    println(d()) // 100\n    println(c()) // 2\n    println(d()) // 101\n}\n```\n\nEach call to `genFunc` will generate a function value. This function value captures the local variable `n`. Each time the function value is executed, the captured `n` will be incremented by 1. The function obtained by executing `genFunc` multiple times value, the `n` they capture is different, and each time it is executed, a new instance is captured.\n\nThe anonymous function value declared within the function carries the state of the local variables captured during this run. Obviously, this function value is essentially a closure.\n",
            "code": "func useFunc(i: i32, f: func(i32) => i32) {\n\tif f == nil {\n\t\tprintln(\"f == nil\")\n\t\treturn\n\t}\n\tprintln(f(i))\n}\n\nfunc genClosure(i: i32) => func() => i32 {\n\tn := i\n\treturn func() => i32 {\n\t\tn = n + 1\n\t\treturn n\n\t}\n}\n\nfunc main {\n\tf := func(i: i32) => i32 { return i * i }\n\tuseFunc(3, f)\n\n\tn: i32 = 0\n\tf = func(i: i32) => i32 {\n\t\tn = i * i\n\t\treturn n\n\t}\n\tuseFunc(3, f)\n\tprintln(n)\n\n\tc := genClosure(0)\n\td := genClosure(99)\n\tprintln(c())\n\tprintln(d())\n\tprintln(c())\n\tprintln(d())\n}\n"
          },
          "4.4.ifStatements": {
            "title": "4.4.ifStatements",
            "path": "en/4.Function/4.4.ifStatements.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 4.4. if statements\n\nThe general form of conditional statements is:\n```wa\nif initial statement, conditional expression {\n    code block 1\n} else {\n    Code block 2\n}\n```\n\nAmong them, `conditional expression` must be of Boolean type. The conditional statement first executes the optional `initial statement` (`initial statement,` can be omitted, which means there is no initial action), and then determines whether `conditional expression` is` true`, if so, execute `Code Block 1`, otherwise execute `Code Block 2`. `else {...}` may be omitted if no action is required if `conditional_expression` is `false`.\n\nIt should be noted that by default, statement ends with a line break, so the `else` statement needs to be on the same line as the `}` of the `if` code block. If `else` starts a new line, a compilation error will occur.\n\nThe following is an example of multiple conditional statement:\n```wa\nfunc Compare(x, y: int) => int {\n    if x < y {\n        return 1\n    } else if x > y {\n        return -1\n    } else {\n        return 0\n    }\n}\n```\n",
            "code": "func Compare(x, y: int) => int {\n\tif x < y {\n\t\treturn 1\n\t} else if x > y {\n\t\treturn -1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc main {\n\tprintln(Compare(1, 2))\n\tprintln(Compare(2, 1))\n\tprintln(Compare(1, 1))\n}\n"
          },
          "4.5.forStatements": {
            "title": "4.5.forStatements",
            "path": "en/4.Function/4.5.forStatements.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 4.5. for statements\n\nThere are three basic forms of loop statements:\n```wa\nfor { code block }\nfor ConditionalExpression { code block }\nfor InitialStatement; ConditionalExpression; LoopOperationStatement { code block }\n```\n\nAmong them, `for {code block}` will keep looping until the statements in the code block use the `break` keyword to exit the loop. Using the `continue` keyword will skip subsequent statements and execute the next loop, for example:\n```wa\ni: int\nfor {\n    i++\n    if i == 2 {\n        continue\n    }\n    println(i)\n    if i == 3 {\n        break\n    }\n}\n```\nThe above code will output:\n```\n1\n3\n```\n\n`for ConditionalExpression {code block}`, before each time the loop executes `code block`, it will judge whether `ConditionalExpression` is `true`, if so, execute the code block, otherwise exit the loop. Statements within a code block can also use `break` and `continue` to exit the loop or skip subsequent statements to execute the next loop:\n```wa\ni: int\nfor i < 3 {\n    println(i)\n    i++\n}\n```\n\n`for InitialStatement; ConditionalExpression; LoopOperationStatement {code block}`, it first executes the `InitialStatement` once, and then checks whether the `ConditionalExpression` is `true` before each execution of the `code block`, and executes it if it is code block, otherwise exit the loop; after each code block is executed, a `LoopOperationStatement` will be executed. Using the `break` keyword in a code block will exit the loop directly, and using the `continue` keyword will skip subsequent statements and execute the next loop (at this time the `LoopOperationStatement` will still be executed), for example:\n```wa\nfor i := 0; i < 100; i++ {\n    if i == 1 {\n        continue\n    }\n    println(i)\n    if i == 2 {\n        break\n    }\n}\n```\n\nThe above code will output:\n``` zsh\n0\n2\n```\n",
            "code": "func main {\n\ti: int\n\tfor {\n\t\ti++\n\t\tif i == 2 {\n\t\t\tcontinue\n\t\t}\n\t\tprintln(i)\n\t\tif i == 3 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\ti = 0\n\tfor i < 3 {\n\t\tprintln(i)\n\t\ti++\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tif i == 1 {\n\t\t\tcontinue\n\t\t}\n\t\tprintln(i)\n\t\tif i == 2 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n"
          },
          "4.6.switchStatements": {
            "title": "4.6.switchStatements",
            "path": "en/4.Function/4.6.switchStatements.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 4.6. switch statements\n\nswtich statements are often used to replace multiple conditional statements. The general form is:\n```wa\nswitch InitialStatement, ConditionalExpression {\ncase expression1:\n    code block 1\n\ncase expression2:\n    code block 2\n\ndefault:\n    default code block\n}\n```\n\nThe switch statement will first execute the optional `InitialStatement` (the `InitialStatement,` can be omitted, which means there is no initial action), and then judge from top to bottom whether the value of the `ConditionalExpression` equals with a certain `branch expression` if equal, the `code block` of the corresponding branch will be executed; if all branch conditions are not met, the optional `default code block` will be executed (omitting the `default` branch means there is no default code block). For example:\n\n```wa\nfunc f(x: int) {\n    switch x {\n    case 0:\n        println(\"x 为 0\")\n\n    case 1:\n        println(\"x 为 1\")\n\n    default:\n        println(\"x ==\", x)\n    }\n}\n```\n\nNote that switch statements in Wa-lang languages ​​jump out by default: after entering a certain branch and executing the corresponding code block, the branch statement will jump out directly (that is, implicit `break`), which is opposite to the default behavior of C language.\n\nAnother special use of branch statements for type assertions will be described in Section 7.1.\n",
            "code": "func f(x: int) {\n\tswitch x {\n\tcase 0:\n\t\tprintln(\"x is 0\")\n\tcase 1:\n\t\tprintln(\"x is 1\")\n\tdefault:\n\t\tprintln(\"x == \", x)\n\t}\n}\n\nfunc main {\n\tf(0)\n\tf(1)\n\tf(2)\n}\n"
          },
          "readme": {
            "title": "4. Functions",
            "path": "en/4.Function/readme.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n# 4. Functions\n\nFunctions are sequences of statements designed to be reused many times. This chapter introduces the basic usage of Wa-lang functions, as well as features such as function values, anonymous functions, and closures.\n"
          }
        }
      },
      "5.CompositeTypes": {
        "title": "5.CompositeTypes",
        "path": "en/5.CompositeTypes",
        "children": {
          "5.1.Reference": {
            "title": "5.1.Reference",
            "path": "en/5.CompositeTypes/5.1.Reference.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 5.1. Reference\n\nIn Wa-lang, adding the `&` symbol before a variable is called a **reference** operation. Assume that the type of the variable is `T`, and the type of the return value of the reference operation is `*T`, which is called It is a **T-type reference**, for example:\n\n```wa\ni: i32 = 42\nj := &i // The type of j is *i32, that is: reference of i32\n```\n\nAdding the `*` symbol before a reference variable is called a **dereference** operation. The value of the dereference expression is the value of the original variable it refers to, for example:\n```wa\ni: i32 = 42\nj := &i\nprintln(*j) // 42\n```\n\nHere `*j` returns the value of `i`, the same type as `i` is `i32`. Dereference can be assigned, which assigns a value to the referenced original variable, for example:\n```wa\ni: i32 = 13\nj := &i\n*j = 42\nprintln(i) // 42\n```\n\nIt can be seen that the **reference** in the Wa-lang is similar to the **pointer** in C language. However, since Wa-lang uses automatic memory management, this similarity only exists on the surface, so we use **reference** to indicate the difference. The most significant difference between the two can be seen through the following example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc genI32Ref() => *i32 {\n    i: i32 = 9527\n    return &i\n}\n\nfunc main {\n    p := genI32Ref()\n    *p = 13\n    q := genI32Ref()\n    println(*p) // 13\n    println(*q) // 9527\n}\n```\n\nIn Wa-lang, it is legal to pass references across functions. Returning a reference to a local variable is safe and harmless. The compiler and runtime will track the memory used by the variable and automatically perform cleanup. Of course, this leads to another intuitive difference between references and pointers, namely: references cannot perform arithmetic operations.\n\nFor reference type `*T`, `T` can be a basic type, or any composite type or custom type. Multi-level references like `**T` (similar to multi-level pointers in C language) are also legal.\n\nList of known issues:\n- The currently used RC mode cannot automatically recycle orphaned rings, causing memory leaks. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.\n",
            "code": "func genI32Ref() => *i32 {\n\ti: i32 = 9527\n\treturn &i\n}\n\nfunc main {\n\ti: i32 = 42\n\tj := &i\n\tprintln(*j)\n\n\ti = 13\n\t*j = 42\n\tprintln(i)\n\n\tp := genI32Ref()\n\t*p = 13\n\tq := genI32Ref()\n\tprintln(*p)\n\tprintln(*q)\n}\n"
          },
          "5.2.Array": {
            "title": "5.2.Array",
            "path": "en/5.CompositeTypes/5.2.Array.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 5.2. Array\n\nThe basic declaration of an array type is as follows:\n```wa\n[N]T\n```\n\nAmong them, `N` is the array length (a constant integer greater than 0), and `T` is the array element type; for example:\n```wa\na: [3]i32\na[0] = 42\nprintln(a[0]) // 42\n```\n\nLike many languages, Wa-lang use the `x[M]` syntax to access specific elements within an array. When declaring an array variable, you can use the following methods to set the initial value of the array element:\n```wa\na: [3]i32 =\nprintln(a[0], a[1], a[2]) // 13 42 9527\n```\n\n`[3]i32{13, 42, 9527}` declares an array literal, so the declaration of the array variable `a` in the above example can be simplified to:\n```wa\na := [3]i32{13, 42, 9527}\n```\n\nWhen declaring an array literal, the number of elements contained in the subsequent `{}` can be less than the array length (but not greater), and the missing part is a 0 value, for example:\n```wa\na := [3]i32{13, 42}\nprintln(a[2]) // 0\n```\n\nThe built-in function `len` can be used to get the length of an array, which is the number of elements contained in the array, for example:\n```wa\na := [3]i32\nprintln(len(a)) // 3\n```\n\nWhen declaring an array literal, if the array length part is written as `...`, it means that the array length is determined by the number of elements in the following `{}`, for example:\n```wa\na := [...]i32{13, 42}\nprintln(len(a)) // 2\n```\n\n**Arrays are value types in Wa-lang**, for example:\n```wa\na := [...]i32{13, 42}\nb: [2]i32\nb = a\nprintln(b[0], b[1]) // 13 42\nb[0] = 9527\nprintln(a[0]) // 13\n```\n\nIt can be seen that when assigning an array to another array, each corresponding element will be assigned, which means a deep copy operation is performed. Since arrays are values, there is no correlation between assigned arrays.\n\nArrays with the same element type but different lengths are considered different types, so the following program is illegal:\n```wa\na: [2]i32\nb: [3]i32\nb = a // Illegal, different types cannot be assigned\n```\n\nKnown issues:\n- Bounds checking is not performed when accessing array elements via variable subscripts. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.\n- In the current version of the implementation, the array is expanded into a set of linear values. Therefore, when the array is assigned, the number of virtual registers and instructions is an integral multiple of the array length. If the length is too large, the size of the target code will expand rapidly. This problem does not affect syntax compatibility, and subsequent corrections to this problem will not affect existing source code. At this stage, program developers should pay attention to: except for global variables, try not to use arrays with a length greater than 8.\n",
            "code": "func main {\n\ta: [3]i32\n\ta[0] = 42\n\tprintln(a[0])\n\n\tb := [3]i32{13, 42, 9527}\n\tprintln(b[0], b[1], b[2])\n\n\tc := [3]i32{13, 42}\n\tprintln(c[2])\n\n\td := [3]i32{}\n\tprintln(len(d))\n\n\te := [...]i32{13, 42}\n\tprintln(len(e))\n\n\tf := [...]i32{13, 42}\n\tg: [2]i32\n\tg = f\n\tprintln(g[0], g[1])\n\tg[0] = 9527\n\tprintln(f[0])\n}\n"
          },
          "5.3.Slice": {
            "title": "5.3.Slice",
            "path": "en/5.CompositeTypes/5.3.Slice.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 5.3. Slice\n\nThe basic declaration of the slice type is as follows, `T` is the element type:\n```wa\n[]T\n```\n\nThe first impression of slices is very similar to arrays: they are both sequences of objects of a specific type, but there is a huge difference in their actual behavior. A slice is a partial reference to an array, which is often taken from an array, for example:\n```wa\narr := [...]i32{1, 2, 3, 4}\nsl: []i32 = arr[0:2]\nprintln(len(sl))      // 2\nprintln(sl[0], sl[1]) // 1 2\n```\n\nThe expression `arr[m:n]` returns a slice, starting from the `m` element of the array `arr`, with a slice length of `n-m`, similar to the syntax of a string. If `m` is omitted, It means starting from the first element of the array; if `n` is omitted, it means ending at the last element of the array. `m` and `n` must not exceed the actual range of the array, otherwise an exception will be triggered.\n\nThe actual data is not stored in the slice, the object accessed through `[]` is located in the array it refers to, which means that changing the object in the array may affect the slice and vice versa, for example:\n```wa\narr := [...]i32{1, 2, 3, 4}\nsl := arr[0:2]\nprintln(sl[0]) // 1\narr[0] = 13\nprintln(sl[0]) // 13\nsl[1] = 42\nprintln(arr[1]) // 42\n```\n\nThe built-in function `cap` can be used to obtain the available capacity of a slice - the length of the array referenced by the slice minus the starting position of the slice, for example:\n```wa\narr := [...]i32{11, 12, 13, 14}\nsl1 := arr[1:2]\nprintln(len(sl1), cap(sl1)) // 2 3\n```\n\nBy definition, the capacity of a slice is always greater or equal to its length.\n\nAn array can be referenced by multiple slices. If there is overlap between the referenced parts, changes to the overlapping parts will also affect each other, for example:\n```wa\narr := [...]i32{1, 2, 3, 4}\nsl1 := arr[0:2]\nsl2 := arr[1:3]\nprintln(sl2[0]) // 2\nsl1[1] = 42\nprintln(sl2[0]) // 42\n```\n\nIn fact, using the `[m:n]` operator on a slice can also get a new slice, starting from the `m`th element of the source slice. The rest of the rules are similar to getting a slice from an array.\n\nIn addition to referencing arrays or existing slices, slices can also be created directly through the built-in function `make`. The general syntax is:\n```wa\nmake([]T, Len: int, Cap: int) => []T\nmake([]T, Len: int) => []T // Equivalent to make([]T, Len, Len)\n```\n\nThe return value is a slice of type `[]T`, length `Len`, and capacity `Cap`, where `Cap` can be omitted, and the capacity of the slice is `Len`, for example:\n```wa\nsl1 := make([]i32, 3, 5)\nprintln(sl1[0], len(sl1), cap(sl1)) // 0 3 5\n```\n\nWhen using the `make` function to create a slice, an array of length `Cap` is implicitly created and referenced as the slice.\n\nAnother built-in function related to slicing is `append`, which is used to append elements to a slice. The general syntax is:\n```wa\nappend(sl []T, e T) => []T\n```\n\nThis function appends element `e` to the end of slice `s` and returns a new slice. Since function calls in Wa-lang use value passing, the appending behavior will not affect the source slice `s`, so the actual commonly used writing method is as follows:\n```wa\nsl: []i32\n//...\nsl = append(sl, 42)\n```\n\nThat is, assign the new slice returned by `append` to the source slice. `append` not only appends elements to a slice, but also appends another slice, for example:\n```wa\nsl1 := []i32{13, 42}\nsl2 := []i32{9527, 1024}\nsl1 = append(sl1, sl2...)\nprintln(sl1[0], sl1[1], sl1[2], sl1[3]) // 13 42 9527 1024\n```\n\nWhen the appended object is a slice, `...` should be added after the variable name.\n\nSince the slice refers to an array with a fixed length, if the length of the slice does not exceed the available capacity of the array after appending an element using `append`, then the contents of the corresponding element of the array will be replaced by the appended element, for example:\n```wa\narr := [...]i32{1, 2, 3}\nsl1 := arr[0:2]\nsl1 = append(sl1, 5)\nprintln(arr[2]) // 5\n```\n\nIf the length of the new slice exceeds the capacity of the original array, the `append` function will automatically re-apply for a large enough array, copy the elements of the source slice to the new array (a deep copy is automatically performed), and then perform the append. This situation is called slice expansion, for example:\n```wa\narr := [...]i32{1, 2, 3}\nsl1 := arr[:]\nsl2 := append(sl1, 4)\nsl2[0] = 42\nprintln(sl1[0]) // 1\n```\n\nObviously, if a slice expansion occurs, the mutual reference between the new slice and the source slice is severed.\n\nDifferent from the data types introduced in the previous chapter, variables of the slice type are **not comparable** because slices are not pure value types, but have a reference relationship with the underlying array or even other slices, which makes the slice unable to guarantee that the element values ​​in it are unchanged.\n\nSlices can only be compared with the constant `nil`, which is used to determine whether the slice has a value of 0, for example:\n```wa\nsl: []i32\nprintln(sl == nil, sl != nil) // true false\n```\n\nIn fact, if you need to determine whether a slice is empty, you should not compare it with `nil`, but determine whether its length is 0, because there are slices with length 0 but not `nil`, for example:\n```wa\narr := [...]i32{1, 2, 3}\nsl1 := arr[0:0]\nprintln(sl1 == nil, len(sl1), cap(sl1)) // false 0 3\n```\n\nUnless otherwise noted, Wa-lang programs should handle slices of length 0 in the same way as slices of `nil` values. The built-in function `append` meets this requirement. For example, the following program is legal:\n```wa\nsl: []i32 // sl == nil\nsl := append(sl, 5)\nprintln(sl[0]) // 5\n```\n\nKnown issues:\n- Bounds checking is not performed when accessing slice elements. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.\n- No bounds checking was performed when using `[]` to get a new slice from an array or slice. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.\n",
            "code": "func main {\n\tarr := [...]i32{1, 2, 3, 4}\n\tsl: []i32 = arr[0:2]\n\tprintln(len(sl))\n\tprintln(sl[0], sl[1])\n\n\tarr2 := [...]i32{1, 2, 3, 4}\n\tsl2 := arr2[0:2]\n\tprintln(sl2[0])\n\tarr2[0] = 13\n\tprintln(sl2[0])\n\tsl2[1] = 42\n\tprintln(arr2[1])\n\n\tarr3 := [...]i32{11, 12, 13, 14}\n\tsl3 := arr3[1:2]\n\tprintln(len(sl3), cap(sl3))\n\n\tarr4 := [...]i32{1, 2, 3, 4}\n\tsl4 := arr4[0:2]\n\tsl5 := arr4[1:3]\n\tprintln(sl5[0])\n\tsl4[1] = 42\n\tprintln(sl5[0])\n\n\tsl6 := make([]i32, 3, 5)\n\tprintln(sl6[0], len(sl6), cap(sl6))\n\n\tsl7: []i32\n\tsl7 = append(sl7, 42)\n\tprintln(sl7[0])\n\n\tsl8 := []i32{13, 42}\n\tsl9 := []i32{9527, 1024}\n\tsl8 = append(sl8, sl9...)\n\tprintln(sl8[0], sl8[1], sl8[2], sl8[3])\n\n\tsl10: []i32\n\tprintln(sl10 == nil, sl10 != nil)\n}\n"
          },
          "readme": {
            "title": "5. Composite types",
            "path": "en/5.CompositeTypes/readme.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n# 5. Composite types\n\nComposite types are built-in complex types.\n"
          }
        }
      },
      "6.CustomTypes": {
        "title": "6.CustomTypes",
        "path": "en/6.CustomTypes",
        "children": {
          "6.1.Structure": {
            "title": "6.1.Structure",
            "path": "en/6.CustomTypes/6.1.Structure.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 6.1. Structure\n\nThe general form of structure declaration in Wa-lang is:\n```wa\ntype StructName struct {\n    Member list\n}\n```\n\nThe `member list` part is consistent with the variable declaration format, such as the following example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc PrintInfo(i: Info) {\n    println(\"Name:\", i.name, \", Age:\", i.age)\n}\n\nfunc main {\n    i: Info\n    i.name = \"张三\"\n    i.age = 35\n    PrintInfo(i) // Name: 张三 ，Age: 35\n}\n```\n\nLike many languages, Wa-lang use the selection operator `.` to access members of a structure value. In addition, it is important to note that the selection operator `.` can also be used to access members of a structure reference, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc GetInfo() => *Info {\n    i: Info\n    i.name = \"李四\"\n    i.age = 42\n    return &i\n}\n\nfunc main {\n    j := GetInfo() // The type of j is a reference, *Info\n    println(j.name, j.age) // 李四 42\n}\n```\n\nIt can be seen that whether it is a value or a reference, the way to access its members is the same, which is different from C language (C language uses `->` to access members of structure pointers).\n\nThe type of the structure members cannot be the structure itself, because this will cause infinite nesting; in fact, any structure that will cause infinite nesting is illegal, such as two structures containing each other. However, it is legal for a structure to contain references of this type (because the essence of a reference is a pointer). This usage is often used to create linked list structures, such as:\n```wa\ntype Node struct {\n    data: i32\n    next: *Node\n}\n```\n\nExamples of structure literals are as follows:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc main {\n    i := Info{name: \"王五\"}\n    println(j.name, j.age) // 王五 0\n}\n```\n\nWhen declaring a structure literal, `{}` contains a list of member literals, and unlisted members have a value of 0.\n\nIf all member variables in the structure are comparable (that is, the `==` operation can be performed between variables of the member type), then the variables of the structure are also comparable. Among the data types introduced so far, slices are incomparable types, so structures that directly or indirectly contain slices are not comparable. Similar to other types of declarations, structures can be declared in any file within the module, and there is no need to \"declare before using\".\n",
            "code": "type Info :struct {\n\tname: string\n\tage:  i32\n}\n\nfunc PrintInfo(i: Info) {\n\tprintln(\"Name:\", i.name, \"Age:\", i.age)\n}\n\nfunc GetInfo() => *Info {\n\ti: Info\n\ti.name = \"Frank\"\n\ti.age = 42\n\treturn &i\n}\n\ntype Node :struct {\n\tdata: i32\n\tnext: *Node\n}\n\nfunc main {\n\ti: Info\n\ti.name = \"Tom\"\n\ti.age = 35\n\tPrintInfo(i)\n\n\tj := GetInfo()\n\tprintln(j.name, j.age)\n\n\tk := Info{name: \"Jerry\"}\n\tprintln(k.name, k.age)\n}\n"
          },
          "6.2.Method": {
            "title": "6.2.Method",
            "path": "en/6.CustomTypes/6.2.Method.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 6.2. Method\n\nIn addition to encapsulating member data, the biggest role of structures is that they can have methods. In Wa-lang, **method** is a special type of function that is attached to a specific type, see the following example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\n// method declaration：\nfunc Info.Print {\n    println(\"Name:\", this.name, \", Age:\", this.age)\n}\n\nfunc main {\n    i := Info{name: \"Tom\", age: 35}\n    i.Print() // Name: Tom , Age: 35\n}\n```\n\nThe general form of method declaration is as follows:\n```wa\nfunc TypeName.MethodName(parameter list) => (Return value list) {method function body}\n```\n\nThe difference between method declaration and ordinary global function declaration is that `TypeName.` is added to the function name. Inside the method body, `this` is a reference to the type to which the method belongs, and its members can be read and written through `this.`.\n\nIf we only look at the syntax that has been introduced so far, methods and global functions can accomplish the same task. For example, the above example is almost equivalent to the following code:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc Print(this: *Info) {\n    println(\"Name:\", this.name, \", Age:\", this.age)\n}\n\nfunc main {\n    i := Info{name: \"Tom\", age: 35}\n    Print(&i) // Name: Tom , Age: 35\n}\n```\n\nAs shown in the above example, if the first parameter of the global function is set to a reference of a custom type, its role is almost the same as that of the method. In fact, in Wa-lang, from a runtime perspective, the method is a function whose first parameter is a reference to a custom type. So why bother introducing this concept? There are two reasons:\n\n1. Methods help aggregate the functionality of an object;\n1. The concept of `interface` is directly dependent on methods - the set of methods of a type determines the interface it implements, which is introduced in Chapter 7.\n\n> It is important to note that according to the concave language syntax, the method declared using `func T.xxx()...` does not belong to type `T`, but to type `*T`; That is to say, the named type itself cannot have methods, and only the reference of the named type can have methods.\n",
            "code": "type Info :struct {\n\tname: string\n\tage:  i32\n}\n\nfunc Info.Print {\n\tprintln(\"Name:\", this.name, \", Age:\", this.age)\n}\n\nfunc Print(this: *Info) {\n\tprintln(\"Name:\", this.name, \", Age:\", this.age)\n}\n\nfunc main {\n\ti := Info{name: \"Tom\", age: 35}\n\ti.Print()\n\tPrint(&i)\n}\n"
          },
          "6.3.MethodValues": {
            "title": "6.3.MethodValues",
            "path": "en/6.CustomTypes/6.3.MethodValues.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 6.3. Method values\n\nSince methods are also functions, you can use them following the pattern in Section 4.2, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Vertex struct{\n    x, y: i32\n}\n\nfunc Vertex.Scale(s: i32) {\n    this.x *= s\n    this.y *= s\n}\n\nfunc Vertex.Sub(s: i32) {\n    this.x -= s\n    this.y -= s\n}\n\nfunc Vertex.Print {\n    println(\"x:\", this.x, \"y:\", this.y)\n}\n\nfunc FnOp(s: i32) {\n    println(\"FnOp, s:\", s)\n}\n\nfunc main {\n    v := Vertex{x: 100, y:200}\n    op : func(s: i32)\n\n    op = FnOp // op此时是函数值FnOp\n    op(13) // FnOp, s: 13\n\n    op = v.Scale // op此时是方法值v.Scale\n    op(2)\n    v.Print() // x: 200 y: 400\n\n    op = v.Sub // op此时是方法值v.Sub\n    op(50)\n    v.Print() // x: 150 y: 350\n}\n```\n\n`v.Scale` and `v.Sub` are methods of the structure variable `v`. When they are used as values, they are called **method values**. For example, in the above example, they are assigned to `op`. The method value can be called like an ordinary function value, and the call can affect the reference associated with the method (just like calling the original method directly). It can be seen that the method value captures the original object reference and is `stateful`. At this point, method values are similar to closures.\n\nFrom the above example, we can also know that function value variables (such as `op` in the example) can store both function values and method values. For the caller, there is no difference between the two.\n",
            "code": "type Vertex :struct {\n\tx, y: i32\n}\n\nfunc Vertex.Scale(s: i32) {\n\tthis.x *= s\n\tthis.y *= s\n}\n\nfunc Vertex.Sub(s: i32) {\n\tthis.x -= s\n\tthis.y -= s\n}\n\nfunc Vertex.Print {\n\tprintln(\"x:\", this.x, \"y:\", this.y)\n}\n\nfunc FnOp(s: i32) {\n\tprintln(\"FnOp, s:\", s)\n}\n\nfunc main {\n\tv := Vertex{x: 100, y: 200}\n\top: func(s: i32)\n\n\top = FnOp\n\top(13)\n\n\top = v.Scale\n\top(2)\n\tv.Print()\n\n\top = v.Sub\n\top(50)\n\tv.Print()\n}\n"
          },
          "6.4.EmbeddedStructure": {
            "title": "6.4.EmbeddedStructure",
            "path": "en/6.CustomTypes/6.4.EmbeddedStructure.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 6.4. Embedded structure\n\nWhen declaring a structure type, if the type of a member is a structure but the name of it is omitted, this usage is called **embedded structure**. For example, in the following code, the structure `Sc` is embedded The `Sp` member:\n```wa\ntype Sp struct {\n    x: i32\n}\n\ntype Sc struct {\n    Sp // embedded structure\n    y: i32\n}\n```\n\nThe member name of the embedded structure is its type name, and we can still use the selector `.` to access it, such as the following printing code:\n```wa\n    v: Sc\n    println(v.Sp.x)\n```\n\nIn this example, you can even omit the `.Sp` part. For example, the above code is equivalent to the following code:\n```wa\n    v: Sc\n    println(v.x)\n```\n\nIn this usage, the structure `Sp` appears to be embedded in the structure `Sc`, which is where the name **embedded structure** comes from. However, if the structure contains a member with the same name as the embedded structure, it cannot be omitted when accessing the member with the same name of the embedded structure, for example:\n```\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Sp struct {\n    x: i32\n}\n\ntype Sc2 strct {\n    Sp\n    x: f32\n}\n\nfunc main(){\n    v: Sc2\n    println(v.x)    // Print Sc2.x, its type is f32\n    println(v.Sp.x) // Print Sc2.Sp.x, its type is i32\n}\n```\n\nIn addition to being able to reuse the data layout of a type, another important function of an embedded structure is that it can reuse type methods. The structure will automatically have the methods of the embedded type, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Sp struct {\n    x: i32\n}\n\nfunc Sp.Show {\n    println(this.x)\n}\n\ntype Sc struct {\n    Sp\n    y: i32\n}\n\nfunc main {\n    v := Sc{Sp:Sp{x: 42}, y: 13}\n    v.Show() // 42\n}\n```\n> When declaring an embedded structure literal, the name of the embedded structure cannot be omitted, such as `Sc{Sp:Sp{x: 42}, y: 13}` in the above example. If it is omitted like `{x: 42, y : 13}`, it will be considered illegal.\n\nAfter `Sp` is embedded in `Sc`, Sc obtains the method of Sp, so that the variable `v` of type `Sc` can perform the `Show` operation; in this example, `v.Show()` is equivalent to` v.Sp.Show()` . If the structure has a method with the same name as the embedded structure, the processing method is similar to the member with the same name, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Sp struct {\n    x: i32\n}\n\nfunc Sp.Show {\n    println(this.x)\n}\n\ntype Sc struct {\n    Sp\n    x: f32\n}\n\nfunc Sc.Show {\n    println(this.x)\n}\n\nfunc main {\n    v := Sc{Sp:Sp{x: 42}, x: 13.14}\n    v.Show()    // 13.14\n    v.Sp.Show() // 42\n}\n```\n\nIn order to achieve object reuse, Wa-lang does not adopt inheritance (which is different from C++), but uses combination. The embedded structure is a concrete manifestation of **combination**. The embedded structure reuses the memory layout and method set of the embedded type. Together with the interface (to be introduced in Chapter 7), it constitutes Wa-lang's foundation of abstraction and reusing of objects.\n",
            "code": "type Sp :struct {\n\tx: i32\n}\n\ntype Sc :struct {\n\tSp\n\ty: i32\n}\n\ntype Sc2 :struct {\n\tSp\n\tx: f32\n}\n\nfunc Sp.Show {\n\tprintln(this.x)\n}\n\nfunc Sc.Show {\n\tprintln(this.x)\n}\n\nfunc main {\n\tv: Sc\n\tprintln(v.Sp.x)\n\tprintln(v.x)\n\n\tv2: Sc2\n\tprintln(v2.x)\n\tprintln(v2.Sp.x)\n\n\tv3 := Sc{Sp: Sp{x: 42}, y: 13}\n\tv3.Show()\n}\n"
          },
          "6.5.AnonymousStructure": {
            "title": "6.5.AnonymousStructure",
            "path": "en/6.CustomTypes/6.5.AnonymousStructure.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 6.5. Anonymous structure\n\nIn the previous sections of this chapter, the structures we used were declared in the following form:\n```wa\ntype StructName struct {\n    Member list\n}\n```\n\nIn fact, the inner meaning of this grammar is:\n1. The part of `struct {...}` defines a structure;\n1. The `type StructName` part gives a name to the structure just defined.\n\nSo in Wa-lang, is it possible to directly create a structure variable by declaring a structure literal without naming the structure? It is indeed possible. This usage is called **anonymous structure**, for example:.\n```wa\n// 版权 @2021 凹语言 作者。保留所有权利。\n\n//Global anonymous structure variable：\nglobal G: struct{\n    name: string\n    age: i32\n}\n\nfunc main {\n    G.name = \"张三\"\n    G.age = 88\n    println(G.name, \" \", G.age)  // 张三 88\n\n    //local anonymous structure variable：\n    k := struct {name: string; age: i32}{name: \"李四\", age: 66}\n    println(k.name, \" \", k.age)  // 李四 66\n\n    G = k\n    println(G.name, \" \", G.age)  // 李四 66\n}\n```\n\nSince anonymous structures do not have type names, when declaring anonymous structure variables, you can only use `variable name: struct{...}` or its short-declaration form to directly specify the type (structure). In addition, the use of anonymous structures and their members is basically the same as ordinary named structures. Anonymous structures also follow the 0-value initialization rule. In their literal values, members with no initial value specified are all 0-value.\n\nThe most commonly used scenario for anonymous structures is global configuration variables. Many types of global configuration variables will only be used once when declaring the global variable. It is a bit cumbersome to define a separate type for a variable that only has one instance. In this case, an anonymous structure can be used instead (such as the global variable `G` in the above example).\n\nThe named type is located in the namespace of the module, but because the anonymous structure has no name, its definition is actually located in the global space. Therefore, if the memory layout of the two anonymous structure variables is exactly the same (that is, the number of members, corresponding member names, and corresponding members types are consistent), they will be considered to belong to the same type and can be assigned to each other (such as the global variable `G` and the local variable `k` in the above example). This feature still holds even if the two variables are located in different modules. ; This leads to another usage scenario of anonymous structures: passing parameters across modules.\n\nSince an anonymous structure has no type name, according to the syntax rules, methods cannot be added to it.\n",
            "code": "global G: struct {\n\tname: string\n\tage:  i32\n}\n\nfunc main {\n\tG.name = \"Tom\"\n\tG.age = 88\n\tprintln(G.name, \" \", G.age)\n\n\tk := struct {\n\t\tname: string\n\t\tage:  i32\n\t}{name: \"Frank\", age: 66}\n\tprintln(k.name, \" \", k.age)\n\n\tG = k\n\tprintln(G.name, \" \", G.age)\n}\n"
          },
          "readme": {
            "title": "6. Custom types",
            "path": "en/6.CustomTypes/readme.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n# 6. Custom types\n\nCustom types include structures and interfaces generated around structure methods.\n"
          }
        }
      },
      "7.Interface": {
        "title": "7.Interface",
        "path": "en/7.Interface",
        "children": {
          "7.1.NullInterface": {
            "title": "7.1.NullInterface",
            "path": "en/7.Interface/7.1.NullInterface.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 7.1. Null interface - universal wrapper\n\nIn Wa-lang, the simplest interface is the null interface, namely `interface {}`. The method of declaring interface type variables is the same as other types. For example, the following code declares an null interface variable named `i`:\n```wa\ni: interface{}\n```\n\nTraditionally, we generally refer to **interface type variables** as **interface values**. The null interface has a very unique feature: **Any type of value can be assigned to the null interface value**. For example, the following operations are all legal:\n```wa\niface: interface{}\n\niface = 777         // Assigning untyped integer to null interface\niface = 13.14       // Assigning an untyped floating point number to an null interface\niface = \"你好，空接口\" // Assign string to null interface\n\ni: i64 = 58372665865\niface = i // Assign 64-bit integer to null interface\n\n// Assign anonymous structure value to null interface：\niface = struct{name: string; age: i32}{name: \"凹语言\", age: 1}\n```\n\nThis assignment behavior performs a value copy operation, which is equivalent to copying a copy of the original data in the interface value. This copy is called the **concrete value** of the interface value, and the type of the concrete value is called **concrete type**.\n\nSo how to determine the concrete type of an assigned interface value? How to read concrete value? This requires the use of **type assertion** syntax, whose general form is:\n```wa\nv, ok = iface.(Type) // Assert whether the concrete type of iface is Type\n```\n\nAmong them, `v` is a value of type `Type`, and `ok` is a value of type `bool`. After the statement is executed, if `ok` is `true`, it means that the concrete type of the interface value `iface` is indeed` Type`, and its concrete value will be assigned to `v`; otherwise it indicates that the concrete type of `iface` is not `Type`. A example is as follows:\n```wa\n// 版权 @2021 凹语言 作者。保留所有权利。\n\ntype T1 struct {\n    a: i32\n}\n\nfunc main {\n    ival: i32 = 777\n    printConcrete(ival)       // i32: 777\n    printConcrete(\"你好凹语言\") // string: 你好凹语言\n\n    v1 := T1{a: 42}\n    printConcrete(v1) // T1, T1.a: 42\n\n    printConcrete(13.14) // unknown type\n}\n\nfunc printConcrete(iface: interface{}) {\n    ok: bool\n    i: i32\n    s: string\n    t: T1\n\n    i, ok = iface.(i32)\n    if ok {\n        println(\"i32:\", i)\n        return\n    }\n\n    s, ok = iface.(string)\n    if ok {\n        println(\"string:\", s)\n        return\n    }\n\n    t, ok = iface.(T1)\n    if ok {\n        println(\"T1, T1.a:\", t.a)\n        return\n    }\n\n    println(\"unknown type\")\n}\n```\n\nIn the function `printConcrete`, through interface type assertion, the concrete type of the incoming null interface value can be dynamically determined and its concrete value can be obtained. Since there is no floating point assertion within the function, \"unknown type\" is output when a floating point number is entered.\n\nNote that the parameter type of the function `printConcrete` is an null interface (`interface{}`). When calling it in the `main` function, an implicit conversion (copy) is actually performed. For example, the statement `printConcrete(ival)` actually Equivalent to:\n```wa\n    iface: interface{} = ival\n    printConcrete(iface)\n```\n\n> Wa-lang do not allow implicit type conversion in most cases, but interfaces are an exception. When the function parameter type is an interface, if the actual parameter filled in by the caller is a concrete type, the compiler will automatically perform assignment conversion.\n\nIf there are multiple possibilities for the concrete type of the interface value, then using multiple type assertions plus conditional judgment will undoubtedly be cumbersome. In this scenario, you can use branch type assertions in the format of `switch...case...`. For example, the above `printConcrete` function can be rewritten as:\n```wa\nfunc printConcrete(iface: interface{}) {\n    //branch type assertion\n    switch v := iface.(type) {\n    case i32:\n        println(\"i32:\", v)  // v is the concrete value of iface. Under this branch, its type is i32, the same below.\n\n    case string:\n        println(\"string:\", v)\n\n    case T1:\n        println(\"T1, T1.a:\", v.a)\n\n    default:\n        println(\"unknown type\")\n    }\n}\n```\n\nAmong them, `iface.(type)` is a fixed writing method, and each subsequent `case` branch indicates that the concrete type satisfies the branch condition.\n\nAny type of value can be assigned to the null interface. It actually plays the role of a universal wrapper in Wa-lang and is often used to transfer values whose types change dynamically between functions.\n\n> In this article, \"**null interface**\" refers to `interface{}`, which is an interface type whose method set is empty. \"**non-null interface**\" in the next section refers to an interface type whose method set is not empty; When we want to describe an interface value with a value of 0, we will use \"**0 value interface**\", or \"**nil interface**\", please pay attention to the distinction.\n",
            "code": "type T1 :struct {\n\ta: i32\n}\n\nfunc main {\n\tival: i32 = 777\n\tprintConcrete(ival)\n\tprintConcrete(\"Hello, Wa!\")\n\n\tv1 := T1{a: 42}\n\tprintConcrete(v1)\n\n\tprintConcrete(13.14)\n}\n\nfunc printConcrete(iface: interface{}) {\n\tswitch v := iface.(type) {\n\tcase i32:\n\t\tprintln(\"i32:\", v)\n\n\tcase string:\n\t\tprintln(\"string:\", v)\n\n\tcase T1:\n\t\tprintln(\"T1, T1.a:\", v.a)\n\n\tdefault:\n\t\tprintln(\"Unknown type\")\n\t}\n}\n"
          },
          "7.2.Non-nullInterface": {
            "title": "7.2.Non-nullInterface",
            "path": "en/7.Interface/7.2.Non-nullInterface.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 7.2. Non-null interface\n\nAn interface is a collection of methods. The general form of an interface declaration is as follows:\n```wa\ntype InterfaceName interface {\n    MethodSet\n}\n```\n\nThe attributes of methods in the `MethodSet` include the method name and the function signature of the method. For example, we define an interface as follows:\n```wa\ntype Stringer interface {\n    String() => string\n}\n```\n\nThe interface is named `Stringer` and contains a method named `String`, which has no input parameters and returns a string.\n\nIf a method set of a concrete type `T` is a superset of the method set MethodSet_i of a certain interface `I`, then we say: **Type `T` satisfies the interface `I`**. In other words, let the method set of type `T` be `St`, the method set of interface `I` be `Si`, and the necessary and sufficient condition for type `T` to satisfy interface `I` is: any `m ∈ Si `, there exists `m' ∈ St`, such that `m` and `m'` have the same name and the same function signature.\n\n**If the type `T` satisfies the interface `I`, then the value of type `T` will be assigned to the interface value of type `I`**. When performing the assignment operation, the value of type `T` will be Copy to the interface value; this is also the reason why the empty interface is the universal wrapper in the previous section, because according to the above definition, the method set of `interface{}` is empty, and any type can satisfy it.\n\nInterface methods can be called, and the call will dynamically switch to the method with the same name of the concrete value contained in the interface value (if the concrete value contained in the interface value is nil, then the call will trigger a runtime exception). Non-null interface is an important abstraction method in Wa-lang. Different types of objects can satisfy the same interface, so that callers can use different types of objects in a unified way through the interface. Therefore, the essence of the interface is a set of method conventions, and the check of this convention (whether the concrete type satisfies a certain interface), which is completed at compile time. Here is a example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Printer interface {\n    Print()\n}\n\ntype T1 struct {\n    i: i32\n}\n\nfunc T1.Print {\n    println(\"This is T1, this.i:\", this.i)\n}\n\ntype T2 struct {\n    s: string\n}\n\nfunc T2.Print {\n    println(\"This is T2, this.s:\", this.s)\n}\n\nfunc PrintObj(p: Printer) {\n    p.Print()\n}\n\nfunc main {\n    p: Printer\n\n    v1: T1\n    v1.i = 42\n    p = &v1\n    PrintObj(p) // This is T1, this.i: 42\n\n    v2: T2\n    v2.s = \"你好\"\n    p = &v2\n    PrintObj(p) // This is T2, this.s: 你好\n}\n```\n\nIt can be seen that when different objects are encapsulated in the same interface value `p`, and it is used in the same way, its behavior will also change with different object types.\n\nSince the named type itself cannot have methods, but only its reference can have methods (refer to Section 6.2), in the above example, `v1` cannot be assigned to `p`, but only its reference `&v1` can. If you try to assign `v1` to `p`, a compilation error will occur.\n",
            "code": "type Printer :interface {\n\tPrint()\n}\n\ntype T1 :struct {\n\ti: i32\n}\n\nfunc T1.Print {\n\tprintln(\"This is T1, this.i:\", this.i)\n}\n\ntype T2 :struct {\n\ts: string\n}\n\nfunc T2.Print {\n\tprintln(\"This is T2, this.s:\", this.s)\n}\n\nfunc PrintObj(p: Printer) {\n\tp.Print()\n}\n\nfunc main {\n\tp: Printer\n\n\tv1: T1\n\tv1.i = 42\n\tp = &v1\n\tPrintObj(p)\n\n\tv2: T2\n\tv2.s = \"Hello\"\n\tp = &v2\n\tPrintObj(p)\n}\n"
          },
          "7.3.TypeAssertions": {
            "title": "7.3.TypeAssertions",
            "path": "en/7.Interface/7.3.TypeAssertions.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 7.3. Summary of type assertions\n\nSection 7.1 introduces how to obtain the specific value contained in an interface value of type `interface{}` through type assertion. This usage still holds for non-null interface values, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Printer interface {\n    Print()\n}\n\ntype T1 struct {\n    i: i32\n}\n\nfunc T1.Print { println(\"This is T1, this.i:\", this.i) }\n\ntype T2 struct {\n    s: string\n}\n\nfunc T2.Print { println(\"This is T2, this.s:\", this.s) }\n\nfunc doConcrete(p: Printer) {\n    switch v := p.(type) {\n    case *T1:\n        v.Print()\n\n    case *T2:\n        v.Print()\n    }\n}\n\nfunc main {\n    v1 := T1{i: 42}\n    doConcrete(&v1) // This is T1, this.i: 42\n\n    v2 := T2{s: \"hello\"}\n    doConcrete(&v2) // This is T2, this.s: hello\n}\n```\n\nNote that `v.Print()` in function `doConcrete` is a direct call, not an interface call, because in the `case *T1` branch, the type of `v` is `*T1`. In addition, non-null interface values can also perform concrete type assertions in the form of `v, ok = iface.(Type)`, which is consistent with the application method of null interface values in Section 7.1.\n\nIn fact, the usage of type assertions goes beyond this. In some cases, a concrete type `*T` may satisfy multiple interfaces `I1` and `I2` at the same time. Then when the interface value of an `I1` contains concrete value type of `*T`, you can directly obtain an interface value of type `I2` through type assertion on the interface value, for example:\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype I1 interface {\n    f1()\n}\n\ntype I2 interface {\n    f2()\n}\n\ntype T struct {\n    i: i32\n}\n\nfunc T.f1 { println(\"T.f1(), T.i:\", this.i) }\n\nfunc T.f2 { println(\"T.f2(), T.i:\", this.i) }\n\nfunc main {\n    v1 := T{i: 42}\n\n    i1: I1 = &v1\n    i1.f1() // T.f1(), T.i: 42\n\n    i2, ok := i1.(I2) // 断言为另一个接口\n    if ok {\n        i2.f2() // T.f2(), T.i: 42\n    }\n}\n```\n\nThis usage is generally seen in getting a non-null interface from an `interface{}` value.\n\nIn addition to type assertions of the form `v, ok = iface.(Type)`, there is another pattern of type assertions:\n```wa\nv = iface.(Type)\n```\n\nThis mode omits the `ok` flag indicating whether the operation was successful and only returns the value of the asserted type. If a type assertion fails, a runtime exception will be triggered, and it is recommended to only use this pattern if you are absolutely certain that the assertion will not fail.\n",
            "code": "type I1 :interface {\n\tf1()\n}\n\ntype I2 :interface {\n\tf2()\n}\n\ntype T :struct {\n\ti: i32\n}\n\nfunc T.f1 { println(\"T.f1(), T.i:\", this.i) }\n\nfunc T.f2 { println(\"T.f2(), T.i:\", this.i) }\n\nfunc main {\n\tv1 := T{i: 42}\n\n\ti1: I1 = &v1\n\ti1.f1()\n\n\ti2, ok := i1.(I2)\n\tif ok {\n\t\ti2.f2()\n\t}\n}\n"
          },
          "7.4.OtherFeatures": {
            "title": "7.4.OtherFeatures",
            "path": "en/7.Interface/7.4.OtherFeatures.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n## 7.4. Other features of interface\n\nWhen declaring an interface, the interface's method set can contain another interface, for example:\n```wa\ntype I1 interface {\n    f1()\n}\n\ntype I2 interface {\n    I1\n    f2()\n}\n```\n\nUsing this form, the compiler will copy the methods of interface `I1` to the method set of `I2`, which is equivalent to directly adding `f1()` to the method set of `I2`.\n\nIf the method set of interface `I2` is a true superset of the method set of interface `I1`, we say that \"compared with I1, I2 is a small interface\". This statement seems a bit counter-intuitive, but its internal logic is: the interface is For method contracts, since there are more methods in `I2`, the set of types that satisfy `I2` must be a subset of the set of types that satisfy `I1`. From this perspective, the empty interface (`interface{}`) is the largest interface. The more methods contained in a non-empty interface, the smaller the interface tends to be.\n\nWe can also declare anonymous interface values. Anonymous interfaces are similar to anonymous structures in all aspects. They are located in the global namespace (can be used across modules).\n\nInterface calls are slightly slower than direct calls from concrete types, so there is no need to create an interface for behavior (or set of methods) that only one type satisfies.\n\nInterface values are comparable. Two non-nil interface values `i1` and `i2` are equal only if the following conditions are met (that is, the expression `i1==i2` is `true`):\n- The concrete type of `i1` is the same as the concrete type of `i2`, and the types are comparable\n- The concrete value of `i1` is equal to the concrete value of `i2`\n",
            "code": "type I1 :interface {\n\tf1()\n}\n\ntype I2 :interface {\n\tI1\n\tf2()\n}\n\ntype T :struct{}\n\nfunc T.f1 { println(\"T.f1()\") }\nfunc T.f2 { println(\"T.f2()\") }\n\nfunc main {\n\tt := T{}\n\ti2: I2 = &t\n\ti2.f1()\n\ti2.f2()\n}\n"
          },
          "readme": {
            "title": "7. Interface",
            "path": "en/7.Interface/readme.md",
            "docs": "*The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: [https://github.com/wa-lang/man/tree/master/en](https://github.com/wa-lang/man/tree/master/en)*\n\n***Ending's law: \"Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.\"***\n\n# 7. Interface\n\nInterface is the soul of the abstract ability of the language. Wa-lang codes that do not use interfaces are pure realism, but with interfaces, abstraction can be achieved through duck-type object-oriented code. This chapter describes the basic usage of interfaces.\n"
          }
        }
      }
    }
  },
  "zh": {
    "title": "zh",
    "path": "zh",
    "children": {
      "1.安装及入门": {
        "title": "1.安装及入门",
        "path": "zh/1.安装及入门",
        "children": {
          "1.1.你好凹语言": {
            "title": "1.1.你好凹语言",
            "path": "zh/1.安装及入门/1.1.你好凹语言.md",
            "docs": "## 1.1. 你好，凹语言\n\n打印“hello world”是C语言之后的惯用案例，凹语言例子打印的是中文“你好，凹语言！”。\n\n### 1.1.1 你好，凹语言！\n\n创建 hello.wa 文件，内容如下：\n\n```wa\n// 版权 @2019 凹语言 作者。保留所有权利。\n\nimport \"fmt\"\nimport \"runtime\"\n\nglobal year: i32 = 2023\n\nfunc main {\n    println(\"你好，凹语言！\", runtime.WAOS)\n    println(add(40, 2), year)\n\n    fmt.Println(\"1+1 =\", 1+1)\n}\n\nfunc add(a: i32, b: i32) => i32 {\n    return a+b\n}\n```\n\n其中`//`开始的是行注释，`import`关键字导入了2个标准库的包，`global`关键字定义了一个全局变量，并给了2023的初始值。`func`关键字定义了`main`函数和`add`函数。`main`函数是程序的入口，其中通过内置的`println`函数打印了“你好，凹语言！”，同时使用`fmt`包的`Println`字符串和整数表达式的结果。在`main`函数还使用了全局的`year`变量，此外还调用了`add`函数并打印了返回值。`add`函数有2个输入参数和一个返回值。\n\n如果在本地已经安装有凹语言的`wa`命令（安装方式参考1.2节），可以输入以下命令执行：\n\n``` zsh\n$ wa run hello.wa\n你好，凹语言！ wasi\n42\n1+1 = 2\n```\n\n### 1.1.2 在线的 Playground\n\n凹语言是面向 WebAssembly 设计的通用编程语言，从诞生起就将浏览器作为第一支持目标。可以通过 [https://wa-lang.org/playground](https://wa-lang.org/playground) 访问 Playground，界面如下：\n\n点击“RUN”按钮，可以看到输出结果。\n",
            "code": "import \"fmt\"\nimport \"runtime\"\n\nglobal year: i32 = 2023\n\nfunc main {\n\tprintln(\"你好，凹语言！\", runtime.WAOS)\n\tprintln(add(40, 2), year)\n\n\tfmt.Println(\"1+1 =\", 1+1)\n}\n\nfunc add(a: i32, b: i32) => i32 {\n\treturn a + b\n}\n"
          },
          "1.2.安装凹语言": {
            "title": "1.2.安装凹语言",
            "path": "zh/1.安装及入门/1.2.安装凹语言.md",
            "docs": "## 1.2. 安装凹语言\n\n除了访问在线的凹语言 Playground，也可以在本地安装凹语言。\n\n### 1.2.1 二进制安装\n\n从 Github 下载最新的二进制文件：[https://github.com/wa-lang/wa/releases](https://github.com/wa-lang/wa/releases) 。需要确保和本地平台对应，比如 v0.8.1 对应 macOS/amd64 平台下载的是 [wa_0.8.1_darwin_amd64.tar.gz](https://github.com/wa-lang/wa/releases/download/v0.8.1/wa_0.8.1_darwin_amd64.tar.gz)。\n\n解压后目录内容如下：\n\n``` zsh\n$ tree ./wa_0.8.1_darwin_amd64\n./wa_0.8.1_darwin_amd64\n├── LICENSE\n├── README-zh.md\n├── README.md\n└── wa\n\n1 directory, 5 files\n```\n\n将该目录路径添加到系统的 `PATH` 环境，然后重新打开命令行环境执行 `wa -v` 命令查看版本信息。\n\n``` zsh\n$ wa -v\nWa version v0.8.1\n```\n\n第一次执行 `wa` 命令时会在命令同一个目录下生成一个 `wa.wat2wasm.exe` 命令。\n\n到此安装工作完成。\n\n### 1.2.2 从源码安装\n\n本地要求安装 Go1.17+ 版本，然后执行以下命令安装最新的 `wa` 命令：\n\n``` zsh\ngo install wa-lang.org/wa\n```\n\n默认会安装到 `$HOME/go/bin` 目录，因此需要将该该目录路径添加到系统的 `PATH` 环境。\n然后重新打开命令行环境执行一次 `wa` 命令会输出以上相同的帮助信息。\n\n第一次执行 `wa -v` 命令查看版本信息时会在命令同一个目录下生成一个 `wa.wat2wasm.exe` 命令。\n\n到此安装工作完成。\n\n### 1.2.3 Homebrew (MacOS & Linux)\n\n对于 macOS 和 Linux 系统也可以通过 Homebrew 安装：\n\n``` zsh\nbrew install wa-lang/tap/wa\n```\n\n### 1.2.4 Scoop (Windows)\n\n对于 Windows 系统也可以通过 Scoop 安装：\n\n``` zsh\nscoop bucket add wa-lang https://github.com/wa-lang/scoop-bucket.git\nscoop install wa-lang/wa\n```\n\n### 1.2.5 本地 Playground\n\n安装成功之后，在命令行输入 `wa play` 可以打开本地 Playground。程序会默认打开浏览器页面，也可以输入 [http://localhost:2023/](http://localhost:2023/) 地址访问。\n"
          },
          "1.3.命令行功能": {
            "title": "1.3.命令行功能",
            "path": "zh/1.安装及入门/1.3.命令行功能.md",
            "docs": "## 1.3. 命令行功能\n\n本节介绍 `wa` 命令主要功能。\n\n### 1.3.1. 帮助信息\n\n输入 `wa` 命令或 `wa -h` 可查看命令行帮助信息，如下：\n\n``` zsh\n$ wa\nNAME:\n   Wa - Wa is a tool for managing Wa source code.\n\nUSAGE:\n   wa [global options] command [command options] [arguments...]\n\nVERSION:\n   v0.8.1-mvp\n\nCOMMANDS:\n   play   start Wa playground\n   init   init a sketch Wa module\n   build  compile Wa source code\n   run    compile and run Wa program\n   fmt    format Wa source code file\n   test   test Wa packages\n   yacc   generates parsers for LALR(1) grammars\n   logo   print Wa text format logo\n\nGLOBAL OPTIONS:\n   --debug, -d              set debug mode (default: false)\n   --trace value, -t value  set trace mode (*|app|compiler|loader)\n   --help, -h               show help (default: false)\n   --version, -v            print the version (default: false)\n\nCOPYRIGHT:\n   Copyright 2018 The Wa Authors. All rights reserved.\n\nSee \"https://wa-lang.org\" for more information.\n```\n\n主要有以下子命令：\n\n- play：启动本地版本的 playground；\n- init：初始化一个凹语言工程；\n- build：编译凹语言程序；\n- run：编译并执行凹语言程序；\n- fmt：格式化凹语言源代码文件；\n- test：执行凹语言工程的单元测试；\n- yacc：凹语言版本的 yacc，用于生成 LALR(1) 语法规则的解析器代码；\n- logo：打印凹语言文字版本的Logo。\n\n其中 build 命令在 1.1.1 节展示过，play 命令已经在 1.2.5 节展示过，本节简要介绍之外的子命令。\n\n### 1.3.2 初始化工程\n\n在 1.1.1 节已经展示过 `wa run hello.wa` 执行一个独立文件的凹语言程序。但是单文件的凹语言程序有一个巨大的限制——它只有一个文件且不能引用非标准库的代码。对于更大的凹程序推荐用凹工程的方式组织。\n\n使用 `wa init` 命令可以初始化一个凹工程，先看看命令行帮助：\n\n``` zsh\n$ wa init -h\nNAME:\n   wa init - init a sketch Wa module\n\nUSAGE:\n   wa init [command options] [arguments...]\n\nOPTIONS:\n   --name value, -n value     set app name (default: \"hello\")\n   --pkgpath value, -p value  set pkgpath file (default: \"myapp\")\n   --update, -u               update example (default: false)\n   --help, -h                 show help (default: false)\n```\n\n该命令有 `-name` 和 `-pkgpath` 两个重要的参数，分别对应工程的名字和对应的包路径。每个参数都有默认值，可以用 `wa init` 生成一个 hello 工程。\n\n``` zsh\n$ wa init\n$ tree hello\nhello\n├── LICENSE\n├── README.md\n├── src\n│   ├── main.wa\n│   ├── mymath\n│   │   └── math.wa\n│   ├── mypkg\n│   │   └── pkg.wa\n│   └── zz_test.wa\n├── vendor\n│   └── 3rdparty\n│       └── pkg\n│           └── pkg.wa\n└── wa.mod\n\n7 directories, 8 files\n```\n\n工程的结构在 1.4 节介绍。\n\n### 1.3.3 编译和执行\n\n命令行环境进入 hello 目录，输入 `wa build` 将在 output 目录构建出 wasm 模块：\n\n``` zsh\n$ wa build\n$ tree output/\noutput/\n├── hello.wasm\n└── hello.wat\n\n1 directory, 2 files\n```\n\n默认输出的是 WASI 规范的 `output/hello.wat` 和 `output/hello.wasm` 文件。可以用标准的工具执行输出的 wasm 模块。也可以用 `wa` 命令执行：\n\n``` zsh\n$ wa run ./output/hello.wasm\n你好，凹语言！\n5050\n...\n```\n\n如果不带参数执行 `wa run` 命令，表示编译并执行当前凹语言工程，会先构建出 `output/hello.wasm` 然后再执行。\n\n### 1.3.4 格式化代码\n\n`wa fmt` 命令用于格式化代码，其命令行帮助信息如下：\n\n``` zsh\n$ wa fmt -h\nNAME:\n   wa fmt - format Wa source code file\n\nUSAGE:\n   wa fmt [command options] [<file.wa>|<path>|<path>/...]\n\nOPTIONS:\n   --help, -h  show help (default: false)\n```\n\n命令行参数是要进行格式化的路径：\n\n- `wa fmt file.wa` 格式化指定的凹语言文件\n- `wa fmt path` 格式化指定目录下的全部凹语言文件\n- `wa fmt path/...` 递归格式化指定路径的凹语言文件，含子目录\n\n如果不指定参数，则默认格式化当前目录下全部的凹语言文件。如果当前目录属于凹语言工程中，则默认格式化全部子目录的凹语言文件。\n\n### 1.3.5 单元测试\n\n默认生成的工程会有一个 `src/zz_test.wa` 测试文件，内容如下：\n\n```wa\nfunc TestSum {\n    assert(sum(100) == 5050, \"sum(100) failed\")\n}\n\nfunc ExampleSum {\n    println(sum(100))\n\n    // Output:\n    // 5050\n}\n```\n\n在 `TestSum` 测试函数中通过内置的 `assert` 函数测试 `sum(100)` 的结果为 5050。在 `ExampleSum` 示例测试函数中通过 `// Output:` 测试输出的内容符合期望的结果。\n\n在工程目录的命令行环境通过 `wa test` 命令执行测试：\n\n``` zsh\n$ wa test\nok   myapp 104ms\n```\n\n### 1.3.6 凹语言版本的 yacc\n\nyacc 是用于生成语法解析器的程序，是编译器爱好者的工具。凹语言的 yacc 从 goyacc 移植而来，详细的用法可以参考凹语言官网碎碎念部分的 [相关文章](https://wa-lang.org/smalltalk/st0021.html)。\n\n### 1.3.7 打印 Logo\n\n`wa logo` 可以输出一些文本格式的 Logo 图案，读者可以通过 `wa logo -h` 命令帮助自行探索。\n"
          },
          "1.4.工程目录结构": {
            "title": "1.4.工程目录结构",
            "path": "zh/1.安装及入门/1.4.工程目录结构.md",
            "docs": "## 1.4. 工程目录结构\n\n工程目录结构是整个外围工具工作的基础，比如 init 根据该结构生成工程、包管理工具则依次管理依赖关系。\n\n### 1.4.1 工程目录结构简介\n\n凹语言程序以包来组织代码，包可以是一个单文件，包也可以是一个目录。凹语言自带的 `waroot/examples/hello` 案例的是一个更为完整的工程，其目录结构如下：\n\n``` zsh\nexamples/hello/\n├── LICENSE\n├── README.md\n├── src\n│   ├── main.wa\n│   └── mymath\n│       └── math.wa\n├── vendor\n│   └── 3rdparty\n│       └── pkg\n│           └── pkg.wa\n└── wa.mod\n```\n\n除了版权文件、说明文件外，最重要的是 `wa.mod` 包工程文件，其定义了当前应用的包路径。此外 src 目录下的是当前包路径下的代码，是默认的 main 入口包。\n\n`wa.mod` 文件内容如下：\n\n``` zsh\nname = \"hello\"\npkgpath = \"myapp\"\nversion = \"0.0.1\"\n```\n\n其中 pkgpath 表示当前包的路径，从而可以推导出 mymath 子目录对应的包路径为 `\"myapp/mymath\"`。vendor 目录是依赖的第三方代码，其中 `vendor/3rdparty/pkg` 对应的包路径为 `\"3rdparty/pkg\"`。\n\n### 1.4.2 包管理工具\n\n凹语言目前还没有包管理工具，如果依赖第三方包则需要手工同步 vendor 目录。开发组希望在 MVP 版本后启动包管理工具开放工作。\n"
          },
          "1.5.IDE插件": {
            "title": "1.5.IDE插件",
            "path": "zh/1.安装及入门/1.5.IDE插件.md",
            "docs": "## 1.5. IDE插件\n\n现代化的编程语言一般都会为各种IDE和编辑器提供扩展，以提高编程的体验。凹语言为 VS Code、Fleet 和 Vim 提供了基本插件支持。\n\n### 1.5.1 VS Code 插件\n\n在 VS Code 扩展商店检索 “wa” 即可以查到凹语言插件。安装之后会有基本的语法高亮等功能。\n\n### 1.5.2 Fleet 插件\n\nFleet 插件仓库：[https://github.com/wa-lang/fleet-wa](https://github.com/wa-lang/fleet-wa)\n\n### 1.5.3 Vim 插件\n\nVim 插件仓库：[https://github.com/wa-lang/vim-wa](https://github.com/wa-lang/vim-wa)\n\n> 在编写文档过程中突然得知 Vim 的作者 Bram Moolenaar 去世，谨以此插件祝愿 Vim 永垂不朽！\n\n### 1.5.4 其他编辑器\n\nMVP 之后凹语言的语法已经基本固定，希望社区可以参与其他编辑器支持共建。\n"
          },
          "readme": {
            "title": "1. 安装及入门",
            "path": "zh/1.安装及入门/readme.md",
            "docs": "# 1. 安装及入门\n\n本章讲述了最简单的凹语言例子、如何安装凹语言程序、凹语言IDE插件、凹语言工程目录结构和命令行功能等内容。\n"
          }
        }
      },
      "2.程序结构": {
        "title": "2.程序结构",
        "path": "zh/2.程序结构",
        "children": {
          "2.1.全局声明": {
            "title": "2.1.全局声明",
            "path": "zh/2.程序结构/2.1.全局声明.md",
            "docs": "## 2.1. 全局声明\n\n一个典型的 凹语言 程序源码如下例所示：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nimport \"errors\"\n\nconst PI = 3.1415926\n\nglobal 终极问题的答案: i32\n\nfunc main {\n    终极问题的答案 = getAnswer()\n    println(\"宇宙的答案：\", 终极问题的答案)\n    println(\"π:\", PI)\n\n    err := errors.New(\"!!!\")\n    println(\"err:\", err.Error())\n}\n\nfunc getAnswer => i32 {\n    return 42\n}\n```\n\n> 与很多语言类似，在 凹语言 中，双斜杠 `//` 后至行尾的部分为注释，不产生实际作用。\n\n凹代码由`全局声明`组成，比如在上面的例子中：\n\n- `import \"errors\"` 是一个导入 `errors` 模块的声明\n- `const PI = 3.1415926` 是一个常量声明，它声明了一个名为 `PI` 的常量，值为 3.1415926\n- `global 终极问题的答案: i32` 是一个全局变量声明，它声明了一个名为 `终极问题的答案` 的全局变量，类型为32位整数\n- `func getAnswer => i32 {...}` 是一个函数声明，它声明了一个返回值为32位整数的函数\n\n凹语言 共有5种全局声明，每种声明均由特定的关键字开始（其后跟随该声明对象的实体），声明及对应关键字的关系如下：\n\n- `global` ：全局变量声明\n- `func` ：函数声明\n- `const` ：常量声明\n- `import` ：导入声明\n- `type` ：类型声明\n\n本章接下来的小节将依次简介全局变量声明、函数声明、常量声明、导入声明，类型声明将在第6章单独讲解。\n",
            "code": "import \"errors\"\n\nconst PI = 3.1415926\n\nglobal 终极问题的答案: i32\n\nfunc main {\n\t终极问题的答案 = getAnswer()\n\tprintln(\"宇宙的答案：\", 终极问题的答案)\n\tprintln(\"π:\", PI)\n\n\terr := errors.New(\"!!!\")\n\tprintln(\"err:\", err.Error())\n}\n\nfunc getAnswer => i32 {\n\treturn 42\n}\n"
          },
          "2.2.全局变量声明": {
            "title": "2.2.全局变量声明",
            "path": "zh/2.程序结构/2.2.全局变量声明.md",
            "docs": "## 2.2. 全局变量声明\n\n全局变量声明以关键字 `global` 开始，一般语法如下：\n\n```wa\nglobal 变量名: 类型 = 初始值表达式\n```\n\n比如下面的例子：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nglobal aInt: i32 = 42     // 32位有符号整数\nglobal _num: f32 = 952.7  // 32位浮点数\n\nfunc main {\n    println(aInt)\n    println(_num)\n    println(名字)\n    println(counter)\n}\n\nglobal 名字: string = \"张三\" // 字符串\nglobal counter: u32         // 32位无符号整数\n```\n\n该程序运行的输出如下：\n\n```\n42\n952.7\n张三\n0\n```\n\n全局变量在模块内部的任何地方都可以使用——哪怕全局变量的声明与使用位于不同的源文件中，只要它们位于同一个模块内即可；在同一个源文件内，也并不要求“先声明再使用”，上面的例子中，变量 `名字`、`counter` 就可体现该特点。\n\n需要注意的是，上例中变量 `counter` 声明时没有给出初始值：\n> 在 凹语言 中，未给定初始值的变量一概以0值初始化，这有助于消除不确定性。\n",
            "code": "global aInt: i32 = 42\nglobal _num: f32 = 952.7\nglobal 名字: string = \"张三\"\nglobal counter: u32\n\nfunc main {\n\tprintln(aInt)\n\tprintln(_num)\n\tprintln(名字)\n\tprintln(counter)\n}\n"
          },
          "2.3.函数声明": {
            "title": "2.3.函数声明",
            "path": "zh/2.程序结构/2.3.函数声明.md",
            "docs": "## 2.3. 函数声明\n\n函数声明以关键字 `func` 开始，一般语法如下：\n\n```wa\nfunc 函数名(参数列表) => (返回值列表) {函数体}\n```\n\n比如下面的例子：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc swap(i, j: i32) => (i32, i32) {\n    return j, i\n}\n\nfunc main {\n    a, b := swap(4, 2)\n    println(\"a:\", a, \", b:\", b)\n    println(add(a, b))\n}\n\nfunc add(i, j: i32) => i32 {\n    return i + j\n}\n```\n\n该程序运行的输出如下：\n\n```\na: 2 , b: 4\n6\n```\n\n对于没有返回值的函数，`=> (返回值列表)` 的部分可省略，没有输入参数的函数 `(参数列表)` 的部分可省略，比如上例中的：`func main {...}`，即为：`func main() => () {...}` 的简写。\n\n与全局变量类似，函数可在包内的任何源文件中声明且无需“先声明再使用”。\n\n关于函数的更多信息见第4章。\n",
            "code": "func swap(i, j: i32) => (i32, i32) {\n\treturn j, i\n}\n\nfunc main {\n\ta, b := swap(4, 2)\n\tprintln(\"a:\", a, \", b:\", b)\n\tprintln(add(a, b))\n}\n\nfunc add(i, j: i32) => i32 {\n\treturn i + j\n}\n"
          },
          "2.4.常量声明": {
            "title": "2.4.常量声明",
            "path": "zh/2.程序结构/2.4.常量声明.md",
            "docs": "## 2.4. 常量声明\n\n常量声明以关键字 `const` 开始，一般语法如下：\n\n```wa\nconst 常量名: 类型 = 常量值\n```\n\n比如下面的例子：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nconst Answer: i32 = 42\nconst aConstString: string = \"你好，凹语言\"\n\nfunc main {\n    println(Answer)\n    println(aConstString)\n    println(aConstInt)\n}\n\nconst aConstInt = 13\n```\n\n该程序运行的输出如下：\n\n```\n42\n你好，凹语言\n13\n```\n\n声明常量时，如果不指定类型（比如上例中的 `aConstInt`），那么它将是**无类型常量**，无类型常量有4种类型，分别为：无类型整数、无类型浮点数、无类型字符、无类型字符串，常量值写法如下：\n\n```wa\nconst aUntypedInt = 11       // 无类型整数\nconst aUntypedFloat = 13.0   // 无类型浮点数\nconst aUntypedRune = 'a'     // 无类型字符\nconst aUntypedString = \"abc\" // 无类型字符串\n```\n\n对常量值的算数逻辑运算是在编译时完成的，比如：\n\n```wa\n// 版权 @2019 凹语言 作者。保留所有权利。\n\nconst K = 4200000000000000000000000\nconst J = 4200000000000000000000000\n\nfunc main {\n    println(K/J)\n}\n```\n\n虽然`K`和`J`的值均超过了凹中位数最多的整数类型`i64`的表达范围，但是`K/J`的值仍然能被正确打印。这也侧面体现了**数值常量拥有超过变量基本类型的表达范围和精度**。\n\n将常量赋值给变量时的相关规则，将在第3章详细讨论。\n",
            "code": "const Answer: i32 = 42\nconst aConstString: string = \"你好，凹语言\"\nconst aConstInt = 13\nconst K = 4200000000000000000000000\nconst J = 4200000000000000000000000\n\nconst aUntypedInt = 11\nconst aUntypedFloat = 13.0\nconst aUntypedRune = 'a'\nconst aUntypedString = \"abc\"\n\nfunc main {\n\tprintln(Answer)\n\tprintln(aConstString)\n\tprintln(aConstInt)\n\tprintln(K / J)\n}\n"
          },
          "2.5.导入声明": {
            "title": "2.5.导入声明",
            "path": "zh/2.程序结构/2.5.导入声明.md",
            "docs": "## 2.5. 导入声明\n\n导入声明以关键字 `import` 开始，一般语法如下：\n\n```wa\nimport 导入模块路径\n```\n\n比如下面的例子：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nimport \"errors\"\n\nfunc main {\n    err := errors.New(\"!!!\")\n    println(\"err:\", err.Error())\n}\n\nfunc getAnswer => i32 {\n    return 42\n}\n```\n\n程序开始处的 `import \"errors\"` 声明导入了凹的内置 `errors` 模块，后续的函数中即可使用该模块的公开对象——如例子中的 `errors.New` 函数；`.` 在这里被称为**选择操作符**，它的含义是从左侧的对象（模块）中选择名称与右侧相同的那个对象来使用，该操作符除了用于选择模块公开的函数、全局变量等对象，还用于选择结构体的成员（详见第6章）。\n\n导入声明应位于源文件内的所有非导入声明之前（既位于头部，紧随文件头注释之后）。若导入多个模块，可以使用括号成组导入，形如：\n\n```wa\nimport (\n    \"errors\"\n    \"strconv\"\n)\n```\n\n该声明与下述声明是等价的：\n\n```wa\nimport \"errors\"\nimport \"strconv\"\n```\n\n在导入模块时，可以给模块起别名，一般语法如下：\n\n```wa\nimport 导入模块路径 => 模块别名\n```\n\n这种用法可以解决同时导入两个路径不同，但名字相同的模块时名字冲突的问题，例如：\n\n```wa\nimport (\n    \"errors\"\n    \"mypackage/errors\" => myerrors\n)\n\nfunc main {\n    err := errors.New(\"!!!\")     // 调用内置 errors 模块\n    myerr := myerrors.New(\"!!!\") // 调用 mypackage/errors 模块\n}\n```\n\n> 与其他声明不同，**导入声明的作用范围是当前源文件**，如果一个模块内的两个源文件使用了同一个第三方模块，那么两个文件内都需要其导入声明。\n\n在凹语言中，每个源文件导入的其他模块都**必须被使用**，也就是说，如果导入了一个模块，但并未使用其任何对象，将被视为语法错误。\n",
            "code": "import (\n\t\"errors\"\n)\n\nfunc main {\n\terr := errors.New(\"!!!\")\n\tprintln(\"err:\", err.Error())\n}\n"
          },
          "readme": {
            "title": "2. 程序结构",
            "path": "zh/2.程序结构/readme.md",
            "docs": "# 2. 程序结构\n\n凹语言和其他编程语言一样，一个大的程序是由很多小的部分组成的。本章介绍全局变量声明、函数声明、常量声明、导入声明和类型声明。\n"
          }
        }
      },
      "3.基础数据类型": {
        "title": "3.基础数据类型",
        "path": "zh/3.基础数据类型",
        "children": {
          "3.1.局部变量声明": {
            "title": "3.1.局部变量声明",
            "path": "zh/3.基础数据类型/3.1.局部变量声明.md",
            "docs": "## 3.1. 局部变量声明\n\n第2章介绍了全局变量和常量声明，同样常用的还有局部变量（函数内部定义的变量）声明，它的一般语法为：\n\n```wa\n局部变量名: 数据类型 = 初始值\n```\n\n与全局变量和常量不同的是：局部变量的声明不以关键字开始；在声明局部变量时，如果省略 `= 初始值` 部分，则该变量将以0值初始化，如：\n\n```wa\naI32: i32 = 42\naString: string = \"你好\"\naF32: f32  // 0.0\n```\n\n另一种常用的声明局部变量的语法是使用快捷定义符 `:=` ，语法如下：\n\n```wa\n局部变量名 := 表达式\n```\n\n使用这种写法时变量的类型将与快捷定义符右侧表达式的类型保持一致，且表达式的值将被赋为该局部变量的初始值，如：\n\n```wa\na := 13          // int\nf := 3.14        // f64\ns := genString() // string\n...\nfunc genString() => string { return \"Hello\" }\n```\n\n> 凹语言是静态类型语言，合法表达式的类型可以在编译时推定，因此变量的类型是确定的。该 `:=` 语法类似于C++的 `auto` 类型。\n",
            "code": "func main() {\n\taI32: i32 = 42\n\taString: string = \"你好\"\n\taF32: f32\n\n\ta := 13\n\tf := 3.14\n\ts := genString()\n\n\tprintln(aI32)\n\tprintln(aString)\n\tprintln(aF32)\n\tprintln(a)\n\tprintln(f)\n\tprintln(s)\n}\n\nfunc genString() => string {\n\treturn \"Hello\"\n}\n"
          },
          "3.2.整数": {
            "title": "3.2.整数",
            "path": "zh/3.基础数据类型/3.2.整数.md",
            "docs": "## 3.2. 整数\n\n凹语言目前支持以下几种整数类型：\n\n- `u8` ：无符号8位整数；\n- `u16` ：无符号16位整数；\n- `i32` ：有符号32位整数；\n- `u32` ：无符号32位整数；\n- `i64` ：有符号64位整数；\n- `u64` ：无符号64位整数；\n- `int` ：不定宽有符号整数；\n- `uint` ：不定宽无符号整数；\n- `bool`：布尔型。\n\n其中：\n- `int` 和 `uint` 为不定宽整数，它们的宽度是由目标平台决定的。之所以有不定宽整数类型，是因为目标平台的寻址范围可能不同，内建函数 `len` 等涉及存储范围的操作，需要统一的数据类型以保持代码在不同的目标平台上能正常编译，并充分利用平台寻址范围；\n- `bool` 型实际内存布局为 `u8`，合法取值的字面值为 `true`、`false`，对应内存数值为 1 和 0。\n\n> 当前凹语言的主要目标平台为 **wasm32**，在该平台下，不定宽整数的位宽为32位，既4字节。\n\n除布尔型外的整数支持以下单目运算：\n- `^` ：按位取反\n- `-` ：取算术负值（既用0减去操作数）\n\n例如：\n```wa\ni: u8 = 9\nprintln(^i) // 246\nprintln(-i) // 247\n\nj: i32 = 9\nprintln(^i) // -10\nprintln(-i) // -9\n```\n\n除布尔型外的整数支持以下双目算术运算：\n- `+`：求和，两个操作数类型必须一致，返回值类型与操作数一致；\n- `-`：求差，两个操作数类型必须一致，返回值类型与操作数一致；\n- `*`：求积，两个操作数类型必须一致，返回值类型与操作数一致；\n- `/`：求商，两个操作数类型必须一致，返回值类型与操作数一致；\n- `%`：求余，两个操作数类型必须一致，返回值类型与操作数一致。\n\n例如：\n```wa\ni, j: u8 = 9, 250\nprintln(i + j) // 3\nprintln(i - j) // 15\nprintln(i * j) // 202\nprintln(j / i) // 27\nprintln(j % i) // 7\n```\n\n除布尔型的整数支持以下双目位运算：\n- `&`：按位取与，两个操作数类型必须一致，返回值类型与操作数一致；\n- `|`：按位取或，两个操作数类型必须一致，返回值类型与操作数一致；\n- `^`：按位取异或，两个操作数类型必须一致，返回值类型与操作数一致；\n- `&^`：按位清空，两个操作数类型必须一致，返回值类型与操作数一致。对 `z = x &^ y`，设 `xn`、`yn`、`zn` 分别为 `x`、`y`、`z` 的第n位，则当 `yn` 为1时 `zn` 为0，否则 `zn` 等于 `xn`。该运算等价于 `z = x & (^y)`；\n- `<<`：左移，对 `z = x << y`，`z` 的类型与 `x` 一致，`y` 必须为大于0的整数，移位时低位补0；\n- `>>`：右移，对 `z = x >> y`，`z` 的类型与 `x` 一致，`y` 必须为大于0的整数，移位时高位补0。\n\n例如：\n```wa\ni, j: u16 = 343, 47831\nprintln(i & j)  // 87\nprintln(i | j)  // 48087\nprintln(i ^ j)  // 48000\nprintln(i &^ j) // 256\nprintln(i << 5) // 10976\nprintln(j >> 5) // 1494\n```\n\n加、减、乘、左移等运算的结果可能超过操作数的表达范围，此时将截取低位部分作为结果。\n\n除布尔型的整数支持以下比较运算（双目）：\n- `==`：相等。操作数类型必须一致，返回值为 `bool` 型，符合判断条件返回 `true`，否则返回 `false`，下同；\n- `!=`：不等；\n- `>`：大于；\n- `>=`：大等于；\n- `<`：小于；\n- `<=`：小等于。\n> 如果参与比较的两个操作数中有一个为常数，则常数应位于比较运算符的右侧。\n\n布尔型支持以下单目运算：\n- `!`：取反，操作数为 `false` 返回 `true`，否则返回 `false`。\n\n实际上除了通过2.4节介绍的常量声明的具名常量外，代码中出现的很多字面值，也是常量，比如：\n```wa\ni := 13\n```\n\n代码中的 `13` 就是一个无类型的整数常量。使用无类型整数常量进行变量快捷声明时，变量的类型为不定宽有符号整数（既 `int`），上述代码等价于：\n```wa\ni: int\ni = 13\n```\n\n将整数常量赋值给整数变量时，会在编译时执行类型和范围检查，自动匹配至变量类型——向无符号整数赋予负数常量、或常量值超过被赋值变量宽度等行为将被判定为非法。\n\n整数拥有所有的二元运算符，二元运算符的优先级按以下顺序递减（同一行内的优先级相同，从左至右执行）：\n\n```\n*      /      %      <<       >>     &       &^\n+      -      |      ^\n==     !=     <      <=       >      >=\n&&\n||\n```\n",
            "code": "func main() {\n\ti: u8 = 9\n\tprintln(^i)\n\tprintln(-i)\n\n\tj: i32 = 9\n\tprintln(^j)\n\tprintln(-j)\n\n\tx, y: u8 = 9, 250\n\tprintln(x + y)\n\tprintln(x - y)\n\tprintln(x * y)\n\tprintln(y / x)\n\tprintln(y % x)\n\n\tm, n: u16 = 343, 47831\n\tprintln(m & n)\n\tprintln(m | n)\n\tprintln(m ^ n)\n\tprintln(m &^ n)\n\tprintln(m << 5)\n\tprintln(n >> 5)\n\n\tb1 := true\n\tb2 := false\n\tprintln(!b1)\n\tprintln(!b2)\n}\n"
          },
          "3.3.浮点数": {
            "title": "3.3.浮点数",
            "path": "zh/3.基础数据类型/3.3.浮点数.md",
            "docs": "## 3.3. 浮点数\n\n凹语言目前支持以下两种浮点数（均为IEEE 754标准）：\n\n- `f32` ：32位浮点数；\n- `f64` ：64位浮点数.\n\n浮点数支持以下单目运算符\n\n- `-` ：取算术负值（既用0减去操作数）\n\n例如：\n```wa\ni: f32 = 1.25\nprintln(-i) //-1.25\n```\n\n浮点数支持以下双目算术运算：\n- `+`：求和，两个操作数类型必须一致，返回值类型与操作数一致；\n- `-`：求差，两个操作数类型必须一致，返回值类型与操作数一致；\n- `*`：求积，两个操作数类型必须一致，返回值类型与操作数一致；\n- `/`：求商，两个操作数类型必须一致，返回值类型与操作数一致；\n\n例如：\n```wa\ni, j: f64 = 1, 0.5\nprintln(i + j) // 1.5\nprintln(i - j) // 0.5\nprintln(i * j) // 0.5\nprintln(j / i) // 2\n```\n\n浮点数支持以下比较运算（双目）：\n- `==`：相等。操作数类型必须一致，返回值为 `bool` 型，符合判断条件返回 `true`，否则返回 `false`，下同；\n- `!=`：不等；\n- `>`：大于；\n- `>=`：大等于；\n- `<`：小于；\n- `<=`：小等于。\n\n使用无类型浮点常量进行变量快捷声明时，变量的类型为 `f64`，如下面两种写法是等价的：\n\n```wa\nf := 1.5\n```\n\n```wa\nf: f64 = 1.5\n```\n",
            "code": "func main() {\n\ti: f32 = 1.25\n\tprintln(-i)\n\n\tx, y: f64 = 1, 0.5\n\tprintln(x + y)\n\tprintln(x - y)\n\tprintln(x * y)\n\tprintln(y / x)\n\n\tf := 1.5\n\tprintln(f)\n}\n"
          },
          "3.4.字符串": {
            "title": "3.4.字符串",
            "path": "zh/3.基础数据类型/3.4.字符串.md",
            "docs": "## 3.4. 字符串\n\n字符串在凹语言中被视为基础数据类型，类型名称为：`string`，字符串字面常量通过双引号 `\"\"` 括起定义，采用 UTF-8 编码，例如：\n\n```wa\ns: string = \"你好，凹语言\"\nprintln(s)     // 你好，凹语言\nprintln(\"+42\") // +42\n```\n\n与整数、浮点数类似，字符串变量也可以使用 `:=` 快捷定义，例如：\n```wa\ns := \"编号9527\"\n```\n\n字符串支持加法（`+`）双目操作，返回值为两个字符串的连接，例如：\n\n```wa\ns1 := \"abc\"\ns2 := \"123\"\nprintln(s1 + s2) // abc123\n```\n\n容纳字符串的底层结构是一个字节（既`u8`）数组，可以使用 `[]` 获取其中某个字节的数值，或一个子串，例如：\n\n```wa\ns := \"abcdefg\"\nprintln(s[2])   // 99，既 'c' 的ASCII值\nprintln(s[1:3]) // bc\n```\n\n在这种用法中，`[]` 内的下标单位是**字节**，而不是**字符**。如果源字符串包含非 ASCII 码字符（如中文字符），而下标未处于整字符边界处，则返回的子字串可能非法，例如：\n```wa\ns := \"你好\"\nprintln(s[1:3]) // ��\n```\n\n`s[m:n]` 用法从第`m`个字节处开始截取，返回的字串长度为 `n-m` 字节。若省略 `m` 则表示从字符串开始截取，若省略 `n` 则表示截取至字符串末尾，例如：\n```wa\ns := \"abcdefg\"\nprintln(s[:3]) // abc\nprintln(s[3:]) // defg\n```\n\n从底层数据的角度看，截取子字符串时没有重新申请字节数组拷贝，而是直接引用原始字符串的地址。为避免多个引用同一片内存的字符串相互修改的影响，字符串被设定为不能局部修改——既不能向 `s[n]` 赋值。下述写法是非法的：\n```wa\ns := \"abcdefg\"\ns[0] = 99 // 非法操作\n```\n\n两个字符串间可使用 `==`、`!=` 运算符进行相等、不等判断，例如：\n```wa\ns := \"abc\"\nprintln(s == \"123\") // false\nprintln(s != \"123\") // true\n```\n\n内建函数 `len` 可用于获取字符串长度（以字节为单位），如：\n\n```wa\ns := \"abcdefg\"\nprintln(len(s)) // 7\n```\n\n已知问题列表：\n- 使用 `[]` 获取字符串变量的指定字节或子串时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。\n",
            "code": "func main() {\n\ts: string = \"你好，凹语言\"\n\tprintln(s)\n\tprintln(\"+42\")\n\n\ts2 := \"编号9527\"\n\tprintln(s2)\n\n\ts1 := \"abc\"\n\ts3 := \"123\"\n\tprintln(s1 + s3)\n\n\ts4 := \"abcdefg\"\n\tprintln(s4[2])\n\tprintln(s4[1:3])\n\tprintln(s4[:3])\n\tprintln(s4[3:])\n\n\tprintln(len(s4))\n\n\ts5 := \"abc\"\n\tprintln(s5 == \"123\")\n\tprintln(s5 != \"123\")\n}\n"
          },
          "readme": {
            "title": "3. 基础数据类型",
            "path": "zh/3.基础数据类型/readme.md",
            "docs": "# 3. 基础数据类型\n\n从底层而言，所有的数据都是由比特组成。对应的凹语言基础数据类型有整型数、浮点数、字符串等。本章介绍基本数据类型以及局部变量的使用。\n"
          }
        }
      },
      "4.函数": {
        "title": "4.函数",
        "path": "zh/4.函数",
        "children": {
          "4.1.函数调用": {
            "title": "4.1.函数调用",
            "path": "zh/4.函数/4.1.函数调用.md",
            "docs": "## 4.1. 函数调用\n\n我们在之前的章节中已接触过很多函数，比如常用的内置打印函数 `println`。函数调用的一般语法为：\n\n`函数名(实参列表)`\n\n`实参`指函数调用时实际传入的参数，与之对应的是函数声明时定义的`形参`，形参只在函数体内有效。凹语言在调用函数时，参数使用**值传递**，在函数体内对形参值的变更不会影响实参的值，例如：\n\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc Double(i: i32) => i32 {\n    i = i * 2\n    return i\n}\n\nfunc main {\n    j: i32 = 42\n    println(Double(j)) // 84\n    println(j)         // 42\n}\n```\n\n关键字 `return` 用于退出函数并返回值，一般语法为：\n```wa\nreturn 返回值列表\n```\n\n如果函数有多个返回值，应使用 `,` 分隔，例如：\n\n```wa\nfunc MulRet() => (i32, i32) {\n    return 42, 13\n}\n```\n\n类似于形参，函数声明时可定义具名返回值，例如：\n```wa\nfunc showAnswer() => (answer: i32) {\n    answer = 42\n    return\n}\n```\n\n这种写法等价于：\n```wa\nfunc showAnswer() => i32 {\n    answer: i32\n    answer = 42\n    return answer\n}\n```\n\n与其他变量类似，具名返回值以 0 值初始化。假如某个函数需要返回错误码、分支很多并且大多数分支错误码为 0 值，则使用具名返回值写法可以简化代码。\n\n即使声明了具名返回值，`return` 时仍然可以指定别的值，比如：\n```wa\n// 版权 @2019 凹语言 作者。保留所有权利。\n\nfunc showAnswer() => (answer: i32) {\n    answer = 13\n    return 42\n}\n\nfunc main {\n    println(showAnswer()) // 42\n}\n```\n\n因此我们可以这样来理解：具名返回值实际上是在函数体内定义了一组局部变量，当该函数内的`return` 语句未指明返回值时，自动将这一组局部变量作为返回值填入。\n",
            "code": "func Double(i: i32) => i32 {\n\ti = i * 2\n\treturn i\n}\n\nfunc MulRet() => (i32, i32) {\n\treturn 42, 13\n}\n\nfunc showAnswer() => (answer: i32) {\n\tanswer = 42\n\treturn\n}\n\nfunc main {\n\tj: i32 = 42\n\tprintln(Double(j))\n\tprintln(j)\n\n\ta, b := MulRet()\n\tprintln(a, b)\n\n\tprintln(showAnswer())\n}\n"
          },
          "4.2.函数值": {
            "title": "4.2.函数值",
            "path": "zh/4.函数/4.2.函数值.md",
            "docs": "## 4.2. 函数值\n\n在凹语言中，函数可以被当作一种特殊的值，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc Inc(i: i32) => i32 { return i + 1 }\nfunc Dec(i: i32) => i32 { return i - 1 }\n\nfunc main {\n    f := Inc\n    println(f(42)) // 43\n\n    f = Dec\n    println(f(42)) // 41\n}\n```\n\n上例中，`f` 即为**函数值**，函数值可以被调用，调用方法与函数调用无异。\n\n函数的类型由其参数以及返回值类型决定，通常这些信息被称为**函数签名**（Signature），如果两个函数 A 和 B 拥有相同签名，意味着它们：\n- 参数个数相同；\n- 返回值个数相同；\n- 对于任意 n，函数 A 的第 n 个参数的类型与 B 的第 n 个参数类型相同；\n- 对于任意 m，函数 A 的第 m 个返回值的类型与 B 的第 m 个返回值类型相同。\n\n函数值的类型也是通过函数签名定义的，比如上例中函数值 `f` 的类型为 `func(i32) => i32`，因此上例中 `f` 的快捷声明 `f := Inc` 等价于：\n```wa\nf: func(i32) => i32 // f == nil\nf = Inc\n```\n\n> 与其他类型的值一样，函数值也为0值初始化，对应值为 `nil`\n\n在凹语言中，类型不同的值不能相互赋值，这一点对函数值同样有效，由于函数类型由签名确定，因此将一个函数赋值给签名不同的函数值被视为非法，例如：\n```wa\nfunc Inc(i: i32) => i32 { return i + 1 }\n\nfunc main {\n    f: func(i32)\n    f = Inc // 编译错误\n}\n```\n\n既然被称为“值”，意味着函数值可以作为参数、和返回值在不同函数间传递，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc inc(i: i32) => i32 { return i + 1 }\nfunc dec(i: i32) => i32 { return i - 1 }\nfunc getFunc(opCode: i32) => func(i32) => i32 {\n    if opCode == 0 {\n        return inc\n    } else if opCode == 1 {\n        return dec\n    } else {\n        return nil\n    }\n}\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n    if f == nil {\n        println(\"f == nil\")\n        return\n    }\n    println(f(i))\n}\n\nfunc main {\n    useFunc(42, getFunc(0)) // 43\n    useFunc(42, getFunc(1)) // 41\n    useFunc(42, getFunc(2)) // f == nil\n    getFunc(2)(42)          // 运行时异常\n}\n```\n\n与其他基本类型不同，函数值只能与 `nil` 比较，既：函数值位于操作符 `==`、`!=` 左侧时，右侧只能为 `nil`，对两个非常量函数值执行比较操作被视为非法。\n\n如果被调用的函数值为 `nil`，将触发不可恢复的运行时异常。\n\n函数值与 C 系语言中的函数指针作用类似，可以更灵活的动态调整执行分支。但需要指出的时，相比于直接调用函数，调用函数值有一些额外消耗，性能敏感的场合需要格外注意。\n",
            "code": "func inc(i: i32) => i32 { return i + 1 }\nfunc dec(i: i32) => i32 { return i - 1 }\n\nfunc getFunc(opCode: i32) => func(i32) => i32 {\n\tif opCode == 0 {\n\t\treturn inc\n\t} else if opCode == 1 {\n\t\treturn dec\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n\tif f == nil {\n\t\tprintln(\"f == nil\")\n\t\treturn\n\t}\n\tprintln(f(i))\n}\n\nfunc main {\n\tf := inc\n\tprintln(f(42))\n\tf = dec\n\tprintln(f(42))\n\n\tuseFunc(42, getFunc(0))\n\tuseFunc(42, getFunc(1))\n\tuseFunc(42, getFunc(2))\n}\n"
          },
          "4.3.匿名函数及闭包": {
            "title": "4.3.匿名函数及闭包",
            "path": "zh/4.函数/4.3.匿名函数及闭包.md",
            "docs": "## 4.3. 匿名函数及闭包\n\n上一节介绍了函数值的基本用法，既然函数可被视为值，那么，在凹语言函数内部，是否可以像声明基本类型字面量那样，声明函数字面量？答案是肯定的，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n    if f == nil {\n        println(\"f == nil\")\n        return\n    }\n    println(f(i))\n}\n\nfunc main {\n    f := func(i: i32) => i32 { return i * i } // 声明匿名函数并赋值给 f\n    useFunc(3, f) // 9\n}\n```\n\n其中快捷声明的函数值 `f`，它的初始值是字面量 `func(i: i32) => i32 { return i * i }`，既一个没有名字的函数。在凹语言中，这种没有名字的函数字面量被称为**匿名函数**。在访问者模式、自定义快速排序等应用场景中，经常需要传入一些函数值参数，而这些函数可能仅在当前上下文环境出现一次，为此额外定义模块级的全局函数有诸多不便，这时即可使用匿名函数。\n\n**在函数A内部声明的匿名函数B，可以访问A内部的局部变量**，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc useFunc(i: i32, f: func(i32) => i32) {\n    if f == nil {\n        println(\"f == nil\")\n        return\n    }\n    println(f(i))\n}\n\nfunc main {\n    n: i32 = 0\n    f := func(i: i32) => i32 {\n        n = i * i\n        return n\n    }\n    useFunc(3, f)\n    println(n) // 9\n}\n```\n\n可见函数值 `f` 可以读写外层的局部变量 `n`。再来看一个更加复杂的例子：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\nfunc genClosure(i: i32) => func() => i32 {\n    n := i\n    return func() => i32 {\n        n = n + 1\n        return n\n    }\n}\n\nfunc main {\n    c := genClosure(0)\n    d := genClosure(99)\n\n    println(c()) // 1\n    println(d()) // 100\n    println(c()) // 2\n    println(d()) // 101\n}\n```\n\n每次调用 `genFunc` 都将生成一个函数值，这个函数值捕获了局部变量 `n`，函数值每次执行会对捕获的 `n` 执行加1，多次执行 `genFunc` 所获得的函数值，它们捕获的 `n` 是不同的，每执行一次，捕获一个新的实例。\n\n在函数内声明的匿名函数值，携带了本次运行时捕获的局部变量的状态。显然，这种函数值实质上就是闭包。\n",
            "code": "func useFunc(i: i32, f: func(i32) => i32) {\n\tif f == nil {\n\t\tprintln(\"f == nil\")\n\t\treturn\n\t}\n\tprintln(f(i))\n}\n\nfunc genClosure(i: i32) => func() => i32 {\n\tn := i\n\treturn func() => i32 {\n\t\tn = n + 1\n\t\treturn n\n\t}\n}\n\nfunc main {\n\tf := func(i: i32) => i32 { return i * i }\n\tuseFunc(3, f)\n\n\tn: i32 = 0\n\tf = func(i: i32) => i32 {\n\t\tn = i * i\n\t\treturn n\n\t}\n\tuseFunc(3, f)\n\tprintln(n)\n\n\tc := genClosure(0)\n\td := genClosure(99)\n\tprintln(c())\n\tprintln(d())\n\tprintln(c())\n\tprintln(d())\n}\n"
          },
          "4.4.条件语句": {
            "title": "4.4.条件语句",
            "path": "zh/4.函数/4.4.条件语句.md",
            "docs": "## 4.4. 条件语句\n\n条件语句的一般形式为：\n```wa\nif 初始语句, 条件表达式 {\n    代码块1\n} else {\n    代码块2\n}\n```\n\n其中，`条件表达式` 必须为布尔型，条件语句先执行可选的`初始语句`（`初始语句,` 可省略，此时表示没有初始动作），然后判断 `条件表达式` 是否为 `true`，是则执行 `代码块1`，否则执行 `代码块2`。如果`条件表达式` 为 `false` 时无需执行任何操作，那么 `else {...}` 可省略。\n\n需要注意的是，凹语言默认换行为语句结束，因此 `else` 语句需要跟 `if` 代码块的 `}` 位于同行，若 `else` 新起一行，将产生编译错误。\n\n下面是一个多重条件判断的例子：\n```wa\nfunc Compare(x, y: int) => int {\n    if x < y {\n        return 1\n    } else if x > y {\n        return -1\n    } else {\n        return 0\n    }\n}\n```\n",
            "code": "func Compare(x, y: int) => int {\n\tif x < y {\n\t\treturn 1\n\t} else if x > y {\n\t\treturn -1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc main {\n\tprintln(Compare(1, 2))\n\tprintln(Compare(2, 1))\n\tprintln(Compare(1, 1))\n}\n"
          },
          "4.5.循环语句": {
            "title": "4.5.循环语句",
            "path": "zh/4.函数/4.5.循环语句.md",
            "docs": "## 4.5. 循环语句\n\n循环语句有三种基本形式：\n```wa\nfor { 代码块 }\nfor 条件表达式 { 代码块 }\nfor 初始语句; 条件表达式; 循环操作语句 { 代码块 }\n```\n\n其中 `for { 代码块 }` 将一直循环，直到代码块内的语句使用 `break` 关键字退出循环，使用 `continue` 关键字将略过后续语句，执行下一次循环，例如：\n```wa\ni: int\nfor {\n    i++\n    if i == 2 {\n        continue\n    }\n    println(i)\n    if i == 3 {\n        break\n    }\n}\n```\n上述代码将输出：\n```\n1\n3\n```\n\n`for 条件表达式 { 代码块 }` 循环每次执行 `代码块` 前会判断 `条件表达式` 是否为 `true`，是则执行代码块，否则退出循环。在代码块内的语句也可以使用 `break`、`continue` 退出循环或跳过后续语句执行下一次循环：\n```wa\ni: int\nfor i < 3 {\n    println(i)\n    i++\n}\n```\n\n`for 初始语句; 条件表达式; 循环操作语句 { 代码块 }` 循环先执行一次 `初始语句`，然后每次执行 `代码块` 前判断 `条件表达式` 是否为 `true`，是则执行代码块，否则退出循环；每次代码块执行后，会执行一次 `循环操作语句`。在代码块中使用 `break` 关键字将直接退出循环，使用 `continue` 关键字将跳过后续语句执行下一次循环（此时 `循环操作语句` 仍然会被执行），例如：\n```wa\nfor i := 0; i < 100; i++ {\n    if i == 1 {\n        continue\n    }\n    println(i)\n    if i == 2 {\n        break\n    }\n}\n```\n\n上述代码将输出：\n```\n0\n2\n```\n",
            "code": "func main {\n\ti: int\n\tfor {\n\t\ti++\n\t\tif i == 2 {\n\t\t\tcontinue\n\t\t}\n\t\tprintln(i)\n\t\tif i == 3 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\ti = 0\n\tfor i < 3 {\n\t\tprintln(i)\n\t\ti++\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tif i == 1 {\n\t\t\tcontinue\n\t\t}\n\t\tprintln(i)\n\t\tif i == 2 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n"
          },
          "4.6.分支语句": {
            "title": "4.6.分支语句",
            "path": "zh/4.函数/4.6.分支语句.md",
            "docs": "## 4.6. 分支语句\n\n分支语句常用于替代多重条件语句，一般形式为：\n```wa\nswitch 初始语句, 条件表达式 {\ncase 分支表达式1:\n    代码块1\n\ncase 分支表达式2:\n    代码块2\n\ndefault:\n    默认代码块\n}\n```\n\n分支语句首先会执行可选的 `初始语句`（`初始语句,` 可省略，此时表示没有初始动作），然后从上至下判断 `条件表达式` 的值是否与某条 `分支表达式` 相等，若相等，则执行对应分支的 `代码块`；若所有分支条件均不满足，则执行可选的 `默认代码块`（省略 `default` 分支表示没有默认代码块）。例如：\n\n```wa\nfunc f(x: int) {\n    switch x {\n    case 0:\n        println(\"x 为 0\")\n\n    case 1:\n        println(\"x 为 1\")\n\n    default:\n        println(\"x ==\", x)\n    }\n}\n```\n\n注意凹语言中分支语句默认跳出：进入某个分支，执行完对应代码块后，将直接跳出分支语句（既隐式`break`），这与 C系语言的默认行为相反。\n\n分支语句另一个特殊的用于类型断言的用法见 7.1节。\n",
            "code": "func f(x: int) {\n\tswitch x {\n\tcase 0:\n\t\tprintln(\"x 为 0\")\n\tcase 1:\n\t\tprintln(\"x 为 1\")\n\tdefault:\n\t\tprintln(\"x ==\", x)\n\t}\n}\n\nfunc main {\n\tf(0)\n\tf(1)\n\tf(2)\n}\n"
          },
          "readme": {
            "title": "4. 函数",
            "path": "zh/4.函数/readme.md",
            "docs": "# 4. 函数\n\n函数是语句序列的打包，以便于被多次重复使用。本章介绍凹语言函数基本用法，以及函数值、匿名函数和闭包等特性。\n"
          }
        }
      },
      "5.复合数据类型": {
        "title": "5.复合数据类型",
        "path": "zh/5.复合数据类型",
        "children": {
          "5.1.引用": {
            "title": "5.1.引用",
            "path": "zh/5.复合数据类型/5.1.引用.md",
            "docs": "## 5.1. 引用\n\n在凹语言中，在一个变量前添加 `&` 符号被称为 **取引用** 操作，假设该变量的类型为 `T`，取引用操作返回值的类型为 `*T`，被称为 **T型引用**，例如：\n```wa\ni: i32 = 42\nj := &i // j的类型为 *i32 ，既：i32型引用\n```\n\n在引用型变量前添加 `*` 符号被称为 **解引用** 操作，解引用表达式的值为它所引用的原始变量的值，例如：\n```wa\ni: i32 = 42\nj := &i\nprintln(*j) // 42\n```\n\n在这里 `*j` 返回了 `i` 的值，类型与 `i` 一样为 `i32`。解引用可以被赋值，其作用为向被引用的原始变量赋值，例如：\n```wa\ni: i32 = 13\nj := &i\n*j = 42\nprintln(i) // 42\n```\n\n由此可见，凹语言中的**引用**与C系语言中的**指针**作用类似，但由于凹语言使用自动内存管理，这种相似性仅存在于表面，因此我们使用**引用**这一术语以示区别。二者最显著的不同，可通过下面这个例子窥见一斑：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\nfunc genI32Ref() => *i32 {\n    i: i32 = 9527\n    return &i\n}\n\nfunc main {\n    p := genI32Ref()\n    *p = 13\n    q := genI32Ref()\n    println(*p) // 13\n    println(*q) // 9527\n}\n```\n\n在凹语言中，**跨函数传递引用是合法操作**。返回局部变量的引用安全无害，编译器和运行时会跟踪变量使用的内存，自动执行清理回收。当然这导致了引用与指针的另一个直观的不同，既：引用不能执行算术运算。\n\n对于引用类型 `*T`，`T` 可以是基础类型，也可以是任何复合类型或自定义类型，`**T` 这样的多级引用（类似于C语言多级指针）也是合法的。\n\n已知问题列表：\n- 目前使用的RC模式无法自动回收孤环，进而导致内存泄漏。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。\n",
            "code": "func genI32Ref() => *i32 {\n\ti: i32 = 9527\n\treturn &i\n}\n\nfunc main {\n\ti: i32 = 42\n\tj := &i\n\tprintln(*j)\n\n\ti = 13\n\t*j = 42\n\tprintln(i)\n\n\tp := genI32Ref()\n\t*p = 13\n\tq := genI32Ref()\n\tprintln(*p)\n\tprintln(*q)\n}\n"
          },
          "5.2.数组": {
            "title": "5.2.数组",
            "path": "zh/5.复合数据类型/5.2.数组.md",
            "docs": "## 5.2. 数组\n\n数组类型的基本声明如下：\n```wa\n[N]T\n```\n\n其中，`N` 为数组长度（大等于0常整数），`T` 为数组元素类型；例如：\n```wa\na: [3]i32\na[0] = 42\nprintln(a[0]) // 42\n```\n\n与很多语言类似，凹语言使用 `x[M]` 语法访问数组内的指定元素。数组变量声明时，可使用以下方式设定数组元素初始值：\n```wa\na: [3]i32 =\nprintln(a[0], a[1], a[2]) // 13 42 9527\n```\n\n`[3]i32{13, 42, 9527}` 声明了一个数组字面值，因此上例中数组变量 `a` 的声明可以使用快捷声明简化为：\n```wa\na := [3]i32{13, 42, 9527}\n```\n\n声明数组字面值时，其后 `{}` 内所含元素的个数可以小于数组长度（但不可大于），不足的部分为 0 值，例如：\n```wa\na := [3]i32{13, 42}\nprintln(a[2]) // 0\n```\n\n内置函数 `len` 可用于获取数组长度既数组中所含元素的个数，例如：\n```wa\na := [3]i32\nprintln(len(a)) // 3\n```\n\n声明数组字面值时，若数组长度部分写为 `...`，则表明数组长度由其后 `{}` 内的元素个数决定，例如：\n```wa\na := [...]i32{13, 42}\nprintln(len(a)) // 2\n```\n\n**在凹语言中数组是值类型**，例如：\n```wa\na := [...]i32{13, 42}\nb: [2]i32\nb = a\nprintln(b[0], b[1]) // 13 42\nb[0] = 9527\nprintln(a[0]) // 13\n```\n\n由此可见，将一个数组赋值给另一个数组时，会将其中的每个对应元素都进行赋值，既执行深拷贝操作。由于数组是值，赋值后的数组间不存在相互关联。\n\n元素类型相同，但长度不同的数组，被认为是不同的类型，因此下列程序非法：\n```wa\na: [2]i32\nb: [3]i32\nb = a // 非法，类型不同不可赋值\n```\n\n已知问题：\n- 通过变量下标访问数组元素时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。\n- 在目前版本的实现中，数组被展开为一组线性值，因此数组赋值时，虚拟寄存器和指令数与数组长度成整倍数关系，若长度过大，目标代码的体积会急剧膨胀。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，在现阶段，程序开发者应关注：除全局变量外，尽可能不要使用长度大于8的数组。\n",
            "code": "func main {\n\ta: [3]i32\n\ta[0] = 42\n\tprintln(a[0])\n\n\tb := [3]i32{13, 42, 9527}\n\tprintln(b[0], b[1], b[2])\n\n\tc := [3]i32{13, 42}\n\tprintln(c[2])\n\n\td := [3]i32{}\n\tprintln(len(d))\n\n\te := [...]i32{13, 42}\n\tprintln(len(e))\n\n\tf := [...]i32{13, 42}\n\tg: [2]i32\n\tg = f\n\tprintln(g[0], g[1])\n\tg[0] = 9527\n\tprintln(f[0])\n}\n"
          },
          "5.3.切片": {
            "title": "5.3.切片",
            "path": "zh/5.复合数据类型/5.3.切片.md",
            "docs": "## 5.3. 切片\n\n切片类型的基本声明如下，`T` 为元素类型：\n```wa\n[]T\n```\n\n切片的第一印象与数组很相似：它们都是特定类型对象的序列，但它们的实际行为存在巨大区别，**切片是数组的部分引用**，它时常取自于数组，例如：\n```wa\narr := [...]i32{1, 2, 3, 4}\nsl: []i32 = arr[0:2]\nprintln(len(sl))      // 2\nprintln(sl[0], sl[1]) // 1 2\n```\n\n表达式 `arr[m:n]` 返回一个切片，切片始于数组 `arr` 的第 `m` 个元素，切片长度为 `n-m`，与字符串的类似语法相似，若省略 `m`，则表示始于数组首个元素；若省略 `n`，则终于数组最后一个元素。`m` 和 `n` 不可超过数组实际范围，否则会触发异常。\n\n切片中并不保存实际数据，通过 `[]` 访问到的对象位于它所引用的数组中，这意味着更改数组中的对象可能影响到切片，反之亦然，例如：\n```wa\narr := [...]i32{1, 2, 3, 4}\nsl := arr[0:2]\nprintln(sl[0]) // 1\narr[0] = 13\nprintln(sl[0]) // 13\nsl[1] = 42\nprintln(arr[1]) // 42\n```\n\n内置函数 `cap` 可用于获取切片的可用容量——既切片所引用的数组的长度减去切片开始位置，例如：\n```wa\narr := [...]i32{11, 12, 13, 14}\nsl1 := arr[1:2]\nprintln(len(sl1), cap(sl1)) // 2 3\n```\n\n由定义可知，切片的容量恒大等于其长度。\n\n一个数组可以被多个切片引用，如果引用的部分之间存在重叠，那么重叠部分的更改也会互相影响，例如：\n```wa\narr := [...]i32{1, 2, 3, 4}\nsl1 := arr[0:2]\nsl2 := arr[1:3]\nprintln(sl2[0]) // 2\nsl1[1] = 42\nprintln(sl2[0]) // 42\n```\n\n实际上，对切片使用`[m:n]`操作符也可以获得一个新的切片，新切片始于源切片的第 `m` 个元素，其余规则与从数组中获取一个切片类似。\n\n获取切片的方法除了引用数组或已有切片外，还可以通过内置函数 `make` 直接创建，形式签名为：\n```wa\nmake([]T, Len: int, Cap: int) => []T\nmake([]T, Len: int) => []T // 等价于 make([]T, Len, Len)\n```\n\n返回值是一个类型为 `[]T`、长度为 `Len`、容量为 `Cap` 的切片，其中 `Cap` 可以省略，此时切片的容量为 `Len`，例如：\n```wa\nsl1 := make([]i32, 3, 5)\nprintln(sl1[0], len(sl1), cap(sl1)) // 0 3 5\n```\n\n使用 `make` 函数创建切片时，隐式的创建了一个长度为 `Cap` 的数组，并将其引用为切片。\n\n另一个与切片密切相关的内建函数是 `append`，它用于向切片中追加元素，形式签名为：\n```wa\nappend(sl []T, e T) => []T\n```\n\n该函数将元素 `e` 追加至切片 `s` 的尾部，并返回一个新的切片。由于凹语言的函数调用使用值传递，追加行为不会影响源切片 `s`，因此实际常用的写法如下例：\n```wa\nsl: []i32\n//...\nsl = append(sl, 42)\n```\n\n既将 `append` 返回的新切片赋值给源切片。`append` 不仅向切片中追加元素，还可以追加另一个切片，例如：\n```wa\nsl1 := []i32{13, 42}\nsl2 := []i32{9527, 1024}\nsl1 = append(sl1, sl2...)\nprintln(sl1[0], sl1[1], sl1[2], sl1[3]) // 13 42 9527 1024\n```\n\n当被追加对象是切片时，应在变量名后添加 `...`。\n\n由于切片底层引用了一个长度固定的数组，如果使用 `append` 追加元素后，切片的长度未超过数组可用容量，那么数组对应元素的内容将被替换为追加元素，例如：\n```wa\narr := [...]i32{1, 2, 3}\nsl1 := arr[0:2]\nsl1 = append(sl1, 5)\nprintln(arr[2]) // 5\n```\n\n倘若新切片的长度超过原始数组容量，那么 `append` 函数会自动重新申请一个足够大的数组，将源切片的元素拷贝至新数组（既自动执行了一次深拷贝），然后再执行追加，这种情况我们称为切片扩容，例如：\n```wa\narr := [...]i32{1, 2, 3}\nsl1 := arr[:]\nsl2 := append(sl1, 4)\nsl2[0] = 42\nprintln(sl1[0]) // 1\n```\n\n显然，如果发生了切片扩容，新切片与源切片的相互引用关系就切断了。\n\n与前面章节介绍过的数据类型不同，切片类型的变量**不可比较**，因为切片不是纯值类型，而是与底层数组甚至其他切片存在引用关系，这种关联使得切片在运行时无法保证其中的元素值不变。\n\n切片只能与常量 `nil` 进行比较，用于判断切片是否为 0 值，例如：\n```wa\nsl: []i32\nprintln(sl == nil, sl != nil) // true false\n```\n\n实际上，如果需要判断某个切片是否为空，不应将其与 `nil` 比较，而应判断其长度是否为 0，因为存在长度为 0，但不为 `nil` 的切片，例如：\n```wa\narr := [...]i32{1, 2, 3}\nsl1 := arr[0:0]\nprintln(sl1 == nil, len(sl1), cap(sl1)) // false 0 3\n```\n\n除特别说明外，凹语言程序应以相同的方式处理长度为 0 的切片，与 `nil` 值的切片。内置函数 `append` 既符合该要求，例如下列程序是合法的：\n```wa\nsl: []i32 // sl == nil\nsl := append(sl, 5)\nprintln(sl[0]) // 5\n```\n\n已知问题：\n- 访问切片元素时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。\n- 使用 `[]` 从数组或切片中获取新切片时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。\n",
            "code": "func main {\n\tarr := [...]i32{1, 2, 3, 4}\n\tsl: []i32 = arr[0:2]\n\tprintln(len(sl))\n\tprintln(sl[0], sl[1])\n\n\tarr2 := [...]i32{1, 2, 3, 4}\n\tsl2 := arr2[0:2]\n\tprintln(sl2[0])\n\tarr2[0] = 13\n\tprintln(sl2[0])\n\tsl2[1] = 42\n\tprintln(arr2[1])\n\n\tarr3 := [...]i32{11, 12, 13, 14}\n\tsl3 := arr3[1:2]\n\tprintln(len(sl3), cap(sl3))\n\n\tarr4 := [...]i32{1, 2, 3, 4}\n\tsl4 := arr4[0:2]\n\tsl5 := arr4[1:3]\n\tprintln(sl5[0])\n\tsl4[1] = 42\n\tprintln(sl5[0])\n\n\tsl6 := make([]i32, 3, 5)\n\tprintln(sl6[0], len(sl6), cap(sl6))\n\n\tsl7: []i32\n\tsl7 = append(sl7, 42)\n\tprintln(sl7[0])\n\n\tsl8 := []i32{13, 42}\n\tsl9 := []i32{9527, 1024}\n\tsl8 = append(sl8, sl9...)\n\tprintln(sl8[0], sl8[1], sl8[2], sl8[3])\n\n\tsl10: []i32\n\tprintln(sl10 == nil, sl10 != nil)\n}\n"
          },
          "readme": {
            "title": "5. 复合数据类型",
            "path": "zh/5.复合数据类型/readme.md",
            "docs": "# 5. 复合数据类型\n\n复合数据类型是内置的复杂类型的基础。\n"
          }
        }
      },
      "6.自定义类型": {
        "title": "6.自定义类型",
        "path": "zh/6.自定义类型",
        "children": {
          "6.1.结构体": {
            "title": "6.1.结构体",
            "path": "zh/6.自定义类型/6.1.结构体.md",
            "docs": "## 6.1. 结构体\n\n凹语言中结构体声明的一般形式为：\n```wa\ntype 类型名 struct {\n    成员列表\n}\n```\n\n其中`成员列表`的部分与变量声明格式一致，比如下例：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc PrintInfo(i: Info) {\n    println(\"名字：\", i.name, \"，年龄：\", i.age)\n}\n\nfunc main {\n    i: Info\n    i.name = \"张三\"\n    i.age = 35\n    PrintInfo(i) // 名字： 张三 ，年龄： 35\n}\n```\n\n与很多语言类似，凹语言 使用选择操作符 `.` 访问结构体值的成员。另外需要特别注意的是，选择操作符 `.` 也可以用于访问结构体引用的成员，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc GetInfo() => *Info {\n    i: Info\n    i.name = \"李四\"\n    i.age = 42\n    return &i\n}\n\nfunc main {\n    j := GetInfo() // j 的类型是引用， *Info\n    println(j.name, j.age) // 李四 42\n}\n```\n\n由此可见，无论是值还是引用，访问其成员的方式是一致的，这与 C 语言不同（C 语言使用 `->` 访问结构体指针的成员）。\n\n结构体的成员类型，不能包含结构体本身，因为这会引起无限嵌套；事实上任何会引起无限嵌套的结构体都是非法的，比如两个结构体互相包含对方。但是结构体中包含本类型的引用是合法的（因为引用的实质是指针），这种用法常用于创建链表结构，比如：\n```wa\ntype Node struct {\n    data: i32\n    next: *Node\n}\n```\n\n结构体字面值的例子如下：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc main {\n    i := Info{name: \"王五\"}\n    println(j.name, j.age) // 王五 0\n}\n```\n\n在声明结构体字面值时 `{}` 内为成员字面值列表，未列出的成员为 0 值。\n\n如果结构体内的所有成员变量都可比（既该成员类型的变量间可执行 `==` 操作），则该结构体的变量间也可比。在目前已介绍的数据类型中，切片是不可比类型，因此直接或间接包含切片的结构体均不可比。与其他类型的声明类似，结构体可在模块内的任意文件中声明，且无需“先声明再使用”。\n",
            "code": "type Info :struct {\n\tname: string\n\tage:  i32\n}\n\nfunc PrintInfo(i: Info) {\n\tprintln(\"名字：\", i.name, \"，年龄：\", i.age)\n}\n\nfunc GetInfo() => *Info {\n\ti: Info\n\ti.name = \"李四\"\n\ti.age = 42\n\treturn &i\n}\n\ntype Node :struct {\n\tdata: i32\n\tnext: *Node\n}\n\nfunc main {\n\ti: Info\n\ti.name = \"张三\"\n\ti.age = 35\n\tPrintInfo(i)\n\n\tj := GetInfo()\n\tprintln(j.name, j.age)\n\n\tk := Info{name: \"王五\"}\n\tprintln(k.name, k.age)\n}\n"
          },
          "6.2.方法": {
            "title": "6.2.方法",
            "path": "zh/6.自定义类型/6.2.方法.md",
            "docs": "## 6.2. 方法\n\n自定义类型除了可以通过结构体达到对成员数据的封装外，最大的作用是它们可以拥有**方法**。在凹语言中，**方法**是一类特殊的、依附于特定类型的函数，见下例：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\n// 方法声明：\nfunc Info.Print {\n    println(\"名字：\", this.name, \"，年龄：\", this.age)\n}\n\nfunc main {\n    i := Info{name: \"张三\", age: 35}\n    i.Print() // 名字： 张三 ，年龄： 35\n}\n```\n\n方法声明一般形式如下：\n```wa\nfunc 类型名.方法名(参数列表) => (返回值列表) {方法函数体}\n```\n\n方法声明与普通全局函数声明的区别是函数名的部分增加了 `类型名.` 。在方法体内部，`this` 是方法所属类型的引用，通过 `this.` 可读写其成员。\n\n如果仅从目前已介绍的语法来看，方法和全局函数可以完成同样的功能，比如上述例子和下面的代码几乎等价：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Info struct {\n    name: string\n    age:  i32\n}\n\nfunc Print(this: *Info) {\n    println(\"名字：\", this.name, \"，年龄：\", this.age)\n}\n\nfunc main {\n    i := Info{name: \"张三\", age: 35}\n    Print(&i) // 名字： 张三 ，年龄： 35\n}\n```\n\n如上例所示，如果把全局函数的第一个参数设为自定义类型的引用，那么它的作用和方法几乎是一致的——事实上在凹语言中，从运行时层面看，方法就是首参数为自定义类型引用的函数。既然如此，那么为何要特意引入这一概念呢？原因有两个：\n\n1. 方法有助于聚合对象的功能；\n1. `接口` 这一概念直接依赖于方法——类型的方法集合决定了它所实现的接口，第7章将对此进行介绍。\n\n> 需要特别注意的是，按照凹语言语法，使用 `func T.xxx()...` 声明的方法并不属于类型 `T`，而是属于类型 `*T`——既 `T` 的引用；也就是说具名类型本身不能拥有方法，拥有方法的只能是具名类型的引用。\n",
            "code": "type Info :struct {\n\tname: string\n\tage:  i32\n}\n\nfunc Info.Print {\n\tprintln(\"名字：\", this.name, \"，年龄：\", this.age)\n}\n\nfunc Print(this: *Info) {\n\tprintln(\"名字：\", this.name, \"，年龄：\", this.age)\n}\n\nfunc main {\n\ti := Info{name: \"张三\", age: 35}\n\ti.Print()\n\tPrint(&i)\n}\n"
          },
          "6.3.方法值": {
            "title": "6.3.方法值",
            "path": "zh/6.自定义类型/6.3.方法值.md",
            "docs": "## 6.3. 方法值\n\n由于方法也是函数，因此可以仿照 4.2 节的模式使用它，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Vertex struct{\n    x, y: i32\n}\n\nfunc Vertex.Scale(s: i32) {\n    this.x *= s\n    this.y *= s\n}\n\nfunc Vertex.Sub(s: i32) {\n    this.x -= s\n    this.y -= s\n}\n\nfunc Vertex.Print {\n    println(\"x:\", this.x, \"y:\", this.y)\n}\n\nfunc FnOp(s: i32) {\n    println(\"FnOp, s:\", s)\n}\n\nfunc main {\n    v := Vertex{x: 100, y:200}\n    op : func(s: i32)\n\n    op = FnOp // op此时是函数值FnOp\n    op(13) // FnOp, s: 13\n\n    op = v.Scale // op此时是方法值v.Scale\n    op(2)\n    v.Print() // x: 200 y: 400\n\n    op = v.Sub // op此时是方法值v.Sub\n    op(50)\n    v.Print() // x: 150 y: 350\n}\n```\n\n`v.Scale`、`v.Sub` 是结构体变量 `v` 的方法，当它们被当成值来使用时，被称为**方法值**，比如上例中，它们先后被赋值给了 `op`。方法值可以像普通函数值那样被调用，并且调用时可以影响方法上关联的引用（就如同直接调用原始方法那样），由此可见方法值捕获了原始对象引用，是`带状态`的，在这一点上，方法值与闭包存在相似性。\n\n从上例中还可以得知：函数值变量（比如例中的 `op`），既可以存储函数值，也可以存储方法值，对调用方（caller）来说，二者没有区别。\n",
            "code": "type Vertex :struct {\n\tx, y: i32\n}\n\nfunc Vertex.Scale(s: i32) {\n\tthis.x *= s\n\tthis.y *= s\n}\n\nfunc Vertex.Sub(s: i32) {\n\tthis.x -= s\n\tthis.y -= s\n}\n\nfunc Vertex.Print {\n\tprintln(\"x:\", this.x, \"y:\", this.y)\n}\n\nfunc FnOp(s: i32) {\n\tprintln(\"FnOp, s:\", s)\n}\n\nfunc main {\n\tv := Vertex{x: 100, y: 200}\n\top: func(s: i32)\n\n\top = FnOp\n\top(13)\n\n\top = v.Scale\n\top(2)\n\tv.Print()\n\n\top = v.Sub\n\top(50)\n\tv.Print()\n}\n"
          },
          "6.4.嵌入结构体": {
            "title": "6.4.嵌入结构体",
            "path": "zh/6.自定义类型/6.4.嵌入结构体.md",
            "docs": "## 6.4. 嵌入结构体\n\n在声明结构体类型时，如果某个成员的类型是结构体，但省略该成员的名称，这种用法被称为**嵌入结构体**，例如下面代码中，结构体 `Sc` 中嵌入了 `Sp` 成员：\n```wa\ntype Sp struct {\n    x: i32\n}\n\ntype Sc struct {\n    Sp // 嵌入结构体\n    y: i32\n}\n```\n\n嵌入结构体的成员名称就是其类型名称，我们依然可以使用选择符 `.` 访问它，例如下面的打印代码：\n```wa\n    v: Sc\n    println(v.Sp.x)\n```\n\n在这个例子中，甚至可以省略 `.Sp` 的部分，比如上面的代码跟下述代码是等价的：\n```wa\n    v: Sc\n    println(v.x)\n```\n\n在这种用法中，结构体 `Sp` 看起来似乎被嵌到结构体 `Sc` 中去了，这也是**嵌入结构体**名称的来源。但是如果结构体中包含了和被嵌结构体同样名称的成员，则访问被嵌结构体同名成员时不能进行省略，例如：\n```\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Sp struct {\n    x: i32\n}\n\ntype Sc2 strct {\n    Sp\n    x: f32\n}\n\nfunc main(){\n    v: Sc2\n    println(v.x)    // 打印的是Sc2.x，f32类型\n    println(v.Sp.x) // 打印的是Sc2.Sp.x，i32类型\n}\n```\n\n嵌入结构体除了可以复用类型的数据布局，另一个重要的功能是它可以复用类型方法，结构体会自动拥有被嵌入类型的方法，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Sp struct {\n    x: i32\n}\n\nfunc Sp.Show {\n    println(this.x)\n}\n\ntype Sc struct {\n    Sp\n    y: i32\n}\n\nfunc main {\n    v := Sc{Sp:Sp{x: 42}, y: 13}\n    v.Show() // 42\n}\n```\n> 在声明嵌入结构体字面量时，不能省略被嵌入结构体名，比如上例中的 `Sc{Sp:Sp{x: 42}, y: 13}`，如果省略为 `{x: 42, y: 13}` 将被视为非法。\n\n`Sc` 中 嵌入 `Sp` 后，获得了后者的方法，使得 `Sc` 类型的变量 `v` 可以执行 `Show` 操作；在该例中，`v.Show()` 等价于 `v.Sp.Show()` 。如果结构体拥有和被嵌结构体同样名称的方法，处理方法与同名成员类似，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Sp struct {\n    x: i32\n}\n\nfunc Sp.Show {\n    println(this.x)\n}\n\ntype Sc struct {\n    Sp\n    x: f32\n}\n\nfunc Sc.Show {\n    println(this.x)\n}\n\nfunc main {\n    v := Sc{Sp:Sp{x: 42}, x: 13.14}\n    v.Show()    // 13.14\n    v.Sp.Show() // 42\n}\n```\n\n为了实现对象复用，凹语言没有采用继承的设计（这与C++不同），而是使用了组合的设计。嵌入结构体就是**组合**的具体表现，嵌入结构体复用了被嵌入类型的内存布局和方法集，与接口（将在第7章介绍）一起，构成了凹语言对象抽象、复用的基础。\n",
            "code": "type Sp :struct {\n\tx: i32\n}\n\ntype Sc :struct {\n\tSp\n\ty: i32\n}\n\ntype Sc2 :struct {\n\tSp\n\tx: f32\n}\n\nfunc Sp.Show {\n\tprintln(this.x)\n}\n\nfunc Sc.Show {\n\tprintln(this.x)\n}\n\nfunc main {\n\tv: Sc\n\tprintln(v.Sp.x)\n\tprintln(v.x)\n\n\tv2: Sc2\n\tprintln(v2.x)\n\tprintln(v2.Sp.x)\n\n\tv3 := Sc{Sp: Sp{x: 42}, y: 13}\n\tv3.Show()\n}\n"
          },
          "6.5.匿名结构体": {
            "title": "6.5.匿名结构体",
            "path": "zh/6.自定义类型/6.5.匿名结构体.md",
            "docs": "## 6.5. 匿名结构体\n\n在本章前几节中，我们使用到的结构体都是按以下形式声明的：\n```wa\ntype 类型名 struct {\n    成员列表\n}\n```\n\n实际上该语法的内在含义是：\n1. `struct {...}` 的部分定义了一个结构体；\n1. `type 类型名` 的部分为刚才定义的结构体赋予了一个名字。\n\n那么在凹语言中，是否可以通过声明结构体字面量的方式直接创建一个结构体变量，而无需对该结构体命名？确实是可以的，这种用法被称为**匿名结构体**，例如：\n```wa\n// 版权 @2021 凹语言 作者。保留所有权利。\n\n//全局匿名结构体变量：\nglobal G: struct{\n    name: string\n    age: i32\n}\n\nfunc main {\n    G.name = \"张三\"\n    G.age = 88\n    println(G.name, \" \", G.age)  // 张三 88\n\n    //局部匿名结构体变量：\n    k := struct {name: string; age: i32}{name: \"李四\", age: 66}\n    println(k.name, \" \", k.age)  // 李四 66\n\n    G = k\n    println(G.name, \" \", G.age)  // 李四 66\n}\n```\n\n由于匿名结构体没有类型名，因此声明匿名结构体变量时只能使用 `变量名: struct{...}` 或其快捷定义形式直接指定类型（结构体）。除此之外，匿名结构体以及其成员的使用，与普通的具名结构体基本一致。匿名结构体同样遵循0值初始化规则，其字面值中，未指定初始值的成员均为0值。\n\n匿名结构体最常用的场景是全局配置变量。很多全局配置变量的类型，仅仅在声明该全局变量时会被使用一次，为仅存在一个实例的变量单独定义一个类型略显繁琐，此时即可使用匿名结构体替代（例如上例中的全局变量 `G`）。\n\n具名类型位于模块的名字空间下，但匿名结构体因为没有名字，其定义实际上位于全局空间，因此如果两个匿名结构体变量的内存布局完全一致（既成员个数、对应成员名、对应成员类型均一致），它们将被认为属于同一个类型，可以互相赋值（例如上例中的全局变量 `G` 和 局部变量 `k`），哪怕这两个变量位于不同模块中，该特性依然成立；这引出了匿名结构体的另一个使用场景：跨模块传递参数。\n\n由于匿名结构体没有类型名，因此按照语法规则，无法为其添加方法。\n",
            "code": "global G: struct {\n\tname: string\n\tage:  i32\n}\n\nfunc main {\n\tG.name = \"张三\"\n\tG.age = 88\n\tprintln(G.name, \" \", G.age)\n\n\tk := struct {\n\t\tname: string\n\t\tage:  i32\n\t}{name: \"李四\", age: 66}\n\tprintln(k.name, \" \", k.age)\n\n\tG = k\n\tprintln(G.name, \" \", G.age)\n}\n"
          },
          "readme": {
            "title": "6. 自定义类型",
            "path": "zh/6.自定义类型/readme.md",
            "docs": "# 6. 自定义类型\n\n自定义类型包括结构体、以及围绕结构体方法产生的接口。\n"
          }
        }
      },
      "7.接口": {
        "title": "7.接口",
        "path": "zh/7.接口",
        "children": {
          "7.1.空接口-万能封包器": {
            "title": "7.1.空接口-万能封包器",
            "path": "zh/7.接口/7.1.空接口-万能封包器.md",
            "docs": "## 7.1. 空接口-万能封包器\n\n在凹语言中，最简单的接口是空接口，既 `interface {}`，声明接口类型变量的方法跟其它类型一致，例如下面的代码声明了一个名为 `i` 的空接口变量：\n```wa\ni: interface{}\n```\n\n习惯上我们一般将 **接口类型变量** 称为 **接口值**。空接口有一个非常独特的特性：**任何类型的值都可以赋值给空接口值**，例如下面的操做全是合法的：\n```wa\niface: interface{}\n\niface = 777         // 无类型整数赋值给空接口\niface = 13.14       // 无类型浮点数赋值给空接口\niface = \"你好，空接口\" // 字符串赋值给空接口\n\ni: i64 = 58372665865\niface = i // 64位整数赋值给空接口\n\n// 匿名结构体赋值给空接口：\niface = struct{name: string; age: i32}{name: \"凹语言\", age: 1}\n```\n\n这种赋值行为执行的是传值操作，相当于在接口值内复制了一份原始数据的拷贝，这份拷贝被称为接口值的**具体值**，具体值的类型被称为**具体类型**。\n\n那么如何判断一个已被赋值的接口值所持有的具体类型？如何读取具体值？这就需要用到**类型断言**语法，它的一般形式为：\n```wa\nv, ok = iface.(Type) // 断言iface的具体类型是否为Type\n```\n\n其中 `v` 是类型为 `Type` 的值， `ok` 是 `bool` 型值，该语句执行后，若 `ok` 为 `true`，则表明接口值 `iface` 的具体类型确实是 `Type`，并且其具体值将被赋予 `v`；否则表明 `iface` 的具体类型不为 `Type`。实际示例如下：\n```wa\n// 版权 @2021 凹语言 作者。保留所有权利。\n\ntype T1 struct {\n    a: i32\n}\n\nfunc main {\n    ival: i32 = 777\n    printConcrete(ival)       // i32: 777\n    printConcrete(\"你好凹语言\") // string: 你好凹语言\n\n    v1 := T1{a: 42}\n    printConcrete(v1) // T1, T1.a: 42\n\n    printConcrete(13.14) // 未知类型\n}\n\nfunc printConcrete(iface: interface{}) {\n    ok: bool\n    i: i32\n    s: string\n    t: T1\n\n    i, ok = iface.(i32)\n    if ok {\n        println(\"i32:\", i)\n        return\n    }\n\n    s, ok = iface.(string)\n    if ok {\n        println(\"string:\", s)\n        return\n    }\n\n    t, ok = iface.(T1)\n    if ok {\n        println(\"T1, T1.a:\", t.a)\n        return\n    }\n\n    println(\"未知类型\")\n}\n```\n\n在函数 `printConcrete` 内，通过接口类型断言，可以动态的判断传入的空接口值的具体类型，并获取其具体值。由于函数内未进行浮点数断言，因此输入浮点数时会输出“未知类型”。\n\n注意函数 `printConcrete` 的参数类型为空接口（`interface{}`），在 `main` 函数中调用它时，实际上执行了隐式转换（拷贝），比如语句 `printConcrete(ival)` 实际上等价于：\n```wa\niface: interface{} = ival\nprintConcrete(iface)\n```\n\n> 凹语言在绝大多数情况下不允许隐式类型转换，但接口是个例外。当函数参数类型为接口时，若调用方填入的实参是具体类型，则编译器会自动执行赋值转换的操作。\n\n如果接口值的具体类型存在多种可能，那么使用多个类型断言加条件判断的方法无疑很累赘，在这种场景下，可以使用`switch...case...`格式的分支类型断言，例如上述 `printConcrete` 函数可以改写为：\n```wa\nfunc printConcrete(iface: interface{}) {\n    //分支类型断言\n    switch v := iface.(type) {\n    case i32:\n        println(\"i32:\", v)  // v是iface的具体值，该分支下，其类型为 i32，下同\n\n    case string:\n        println(\"string:\", v)\n\n    case T1:\n        println(\"T1, T1.a:\", v.a)\n\n    default:\n        println(\"未知类型\")\n    }\n}\n```\n\n其中 `iface.(type)` 是固定写法，后续每个 `case` 分支表示具体类型满足该分支条件。\n\n任何类型的值都可以赋予空接口，它在凹语言中实际起到了万能封包器的作用，经常用于在函数间传递类型会动态变化的值。\n\n> 本文中“**空接口**”指 `interface{}`，既方法集为空的接口类型，下一节中的“**非空接口**”指方法集不为空的接口类型；当我们要描述值为0的接口值时，将使用“**0值接口**”，或“**nil接口**”，请注意区分。\n",
            "code": "type T1 :struct {\n\ta: i32\n}\n\nfunc main {\n\tival: i32 = 777\n\tprintConcrete(ival)\n\tprintConcrete(\"你好凹语言\")\n\n\tv1 := T1{a: 42}\n\tprintConcrete(v1)\n\n\tprintConcrete(13.14)\n}\n\nfunc printConcrete(iface: interface{}) {\n\tswitch v := iface.(type) {\n\tcase i32:\n\t\tprintln(\"i32:\", v)\n\n\tcase string:\n\t\tprintln(\"string:\", v)\n\n\tcase T1:\n\t\tprintln(\"T1, T1.a:\", v.a)\n\n\tdefault:\n\t\tprintln(\"未知类型\")\n\t}\n}\n"
          },
          "7.2.非空接口": {
            "title": "7.2.非空接口",
            "path": "zh/7.接口/7.2.非空接口.md",
            "docs": "## 7.2. 非空接口\n\n接口是方法的集合，接口声明的一般形式如下：\n```wa\ntype 接口名 interface {\n    方法集合\n}\n```\n\n在`方法集合`中的方法，其属性包括方法名以及方法的函数签名，比如我们定义一个接口如下：\n```wa\ntype Stringer interface {\n    String() => string\n}\n```\n\n该接口名为 `Stringer`，其中包含一个名为 `String` 的方法，该方法没有输入参数，返回值为字符串。\n\n如果一个具体类型 `T` 的方法集合，是某个接口 `I` 的方法集合 MethodSet_i的超集，那么我们称：**类型 `T` 满足接口 `I`**。换句话说，设类型 `T` 的方法集合为 `St`，接口 `I` 的方法集合为 `Si`，类型 `T` 满足接口 `I` 的充要条件是：任取 `m ∈ Si`，存在 `m' ∈ St`，使得 `m` 与 `m'` 的名字相同，且函数签名相同。\n\n**如果类型 `T` 满足接口 `I`，那么类型为 `T` 的值将可以被赋值给 `I` 型的接口值**，在执行赋值操作时，类型 `T` 的值将被拷贝至接口值内部；这也是上一节中，空接口是万能封包器的由来，因为按照上述定义，`interface{}` 的方法集为空，任何类型都满足它。\n\n接口方法可以被调用，其调用将动态切至接口值内部所包含的具体值的同名方法（如果接口值内部所包含的具体值为nil，那么调用将触发运行时异常）。非空接口是凹语言中重要的抽象手段。不同类型的对象可以满足同一个接口，使得调用者可以通过接口，按照统一的方式使用不同类型的对象，因此接口作用的本质，是一组方法约定，该约定的检查（具体类型是否满足某个接口），是编译时完成的。下面是一个具体的例子：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Printer interface {\n    Print()\n}\n\ntype T1 struct {\n    i: i32\n}\n\nfunc T1.Print {\n    println(\"This is T1, this.i:\", this.i)\n}\n\ntype T2 struct {\n    s: string\n}\n\nfunc T2.Print {\n    println(\"This is T2, this.s:\", this.s)\n}\n\nfunc PrintObj(p: Printer) {\n    p.Print()\n}\n\nfunc main {\n    p: Printer\n\n    v1: T1\n    v1.i = 42\n    p = &v1\n    PrintObj(p) // This is T1, this.i: 42\n\n    v2: T2\n    v2.s = \"你好\"\n    p = &v2\n    PrintObj(p) // This is T2, this.s: 你好\n}\n```\n\n由此可见，同一个接口值 `p` 中封装了不同的对象时，使用同样的方法使用它，其行为也会随着对象类型的不同发生变化。\n\n由于具名类型本身无法拥有方法，而只有其引用才能拥有方法（参考6.2节），因此上例中，`v1` 不能赋值给 `p`，而只有其引用 `&v1` 方可。如果试图将 `v1` 赋值给 `p`，将会引发编译错误。\n",
            "code": "type Printer :interface {\n\tPrint()\n}\n\ntype T1 :struct {\n\ti: i32\n}\n\nfunc T1.Print {\n\tprintln(\"This is T1, this.i:\", this.i)\n}\n\ntype T2 :struct {\n\ts: string\n}\n\nfunc T2.Print {\n\tprintln(\"This is T2, this.s:\", this.s)\n}\n\nfunc PrintObj(p: Printer) {\n\tp.Print()\n}\n\nfunc main {\n\tp: Printer\n\n\tv1: T1\n\tv1.i = 42\n\tp = &v1\n\tPrintObj(p)\n\n\tv2: T2\n\tv2.s = \"你好\"\n\tp = &v2\n\tPrintObj(p)\n}\n"
          },
          "7.3.类型断言总结": {
            "title": "7.3.类型断言总结",
            "path": "zh/7.接口/7.3.类型断言总结.md",
            "docs": "## 7.3. 类型断言总结\n\n7.1节介绍了如何从类型为 `interface{}` 的接口值中通过类型断言获取它所包含的具体值，该用法对于非空接口值依然成立，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype Printer interface {\n    Print()\n}\n\ntype T1 struct {\n    i: i32\n}\n\nfunc T1.Print { println(\"This is T1, this.i:\", this.i) }\n\ntype T2 struct {\n    s: string\n}\n\nfunc T2.Print { println(\"This is T2, this.s:\", this.s) }\n\nfunc doConcrete(p: Printer) {\n    switch v := p.(type) {\n    case *T1:\n        v.Print() // 方法直接调用，而非接口调用\n\n    case *T2:\n        v.Print()\n    }\n}\n\nfunc main {\n    v1 := T1{i: 42}\n    doConcrete(&v1) // This is T1, this.i: 42\n\n    v2 := T2{s: \"hello\"}\n    doConcrete(&v2) // This is T2, this.s: hello\n}\n```\n\n注意函数 `doConcrete` 中 `v.Print()` 是直接调用，而非接口调用，因为在 `case *T1` 分支中，`v` 的类型是 `*T1`。另外，非空接口值也可以通过 `v, ok = iface.(Type)` 形式进行具体类型断言，这与7.1节中空接口值的对应用法一致。\n\n实际上类型断言的用法还不仅于此，在某些情况下，一个具体类型 `*T` 可能同时满足多个接口 `I1`、`I2`，那么当一个 `I1` 的接口值中包含的具体值类型为 `*T` 时，可以在该接口值上通过类型断言，直接获取一个类型为 `I2` 的接口值，例如：\n```wa\n// 版权 @2023 凹语言 作者。保留所有权利。\n\ntype I1 interface {\n    f1()\n}\n\ntype I2 interface {\n    f2()\n}\n\ntype T struct {\n    i: i32\n}\n\nfunc T.f1 { println(\"T.f1(), T.i:\", this.i) }\n\nfunc T.f2 { println(\"T.f2(), T.i:\", this.i) }\n\nfunc main {\n    v1 := T{i: 42}\n\n    i1: I1 = &v1\n    i1.f1() // T.f1(), T.i: 42\n\n    i2, ok := i1.(I2) // 断言为另一个接口\n    if ok {\n        i2.f2() // T.f2(), T.i: 42\n    }\n}\n```\n\n这种用法一般常见于从 `interface{}` 接口值中获取非空接口。\n\n除了形如 `v, ok = iface.(Type)` 的类型断言外，还有另一种模式的类型断言：\n```wa\nv = iface.(Type)\n```\n\n该模式取消了操作成功标志的返回值 `ok`，只返回被断言类型的值。如果类型断言失败，则会触发运行时异常，建议仅在完全确认断言不会失败的情况下才使用该模式。\n",
            "code": "type I1 :interface {\n\tf1()\n}\n\ntype I2 :interface {\n\tf2()\n}\n\ntype T :struct {\n\ti: i32\n}\n\nfunc T.f1 { println(\"T.f1(), T.i:\", this.i) }\n\nfunc T.f2 { println(\"T.f2(), T.i:\", this.i) }\n\nfunc main {\n\tv1 := T{i: 42}\n\n\ti1: I1 = &v1\n\ti1.f1()\n\n\ti2, ok := i1.(I2)\n\tif ok {\n\t\ti2.f2()\n\t}\n}\n"
          },
          "7.4.接口的其它特性": {
            "title": "7.4.接口的其它特性",
            "path": "zh/7.接口/7.4.接口的其它特性.md",
            "docs": "## 7.4. 接口的其它特性\n\n在声明接口时，接口的方法集可以包含另一个接口，例如：\n```wa\ntype I1 interface {\n    f1()\n}\n\ntype I2 interface {\n    I1\n    f2()\n}\n```\n\n使用该形式，编译器会将接口 `I1` 的方法拷贝至 `I2` 的方法集中，这与直接在 `I2` 的方法集中增加 `f1()` 是等价的。\n\n如果接口 `I2` 的方法集是接口 `I1` 方法集的真超集，我们称“与I1相比，I2是小接口”，这一说法看起来有些反直觉，其内在逻辑在于：接口是方法合约，由于 `I2` 中的方法更多，因此满足 `I2` 的类型的集合，一定是满足 `I1` 的类型的集合的子集——或者说满足 `I2` 的类型少等于满足`I1`的类型。从这个角度来说，空接口（`interface{}`）是最大的接口，非空接口中所包含的方法越多，接口倾向于越小。\n\n我们也可以声明匿名接口值，匿名接口各方面都与匿名结构体类似，它们都位于全局名字空间（可跨模块使用）。\n\n接口调用比具体类型直接调用略慢，因此没有必要为只有一种类型满足的行为（或者说方法集）创建接口。\n\n接口值是可比的，只有同时满足以下条件，两个非nil接口值 `i1`、`i2` 才相等（既表达式 `i1==i2` 为 `true`）：\n- `i1` 的具体类型与 `i2` 的具体类型相同，且该类型可比\n- `i1` 的具体值与 `i2` 的具体值相等\n",
            "code": "type I1 :interface {\n\tf1()\n}\n\ntype I2 :interface {\n\tI1\n\tf2()\n}\n\ntype T :struct{}\n\nfunc T.f1 { println(\"T.f1()\") }\nfunc T.f2 { println(\"T.f2()\") }\n\nfunc main {\n\tt := T{}\n\ti2: I2 = &t\n\ti2.f1()\n\ti2.f2()\n}\n"
          },
          "readme": {
            "title": "7. 接口",
            "path": "zh/7.接口/readme.md",
            "docs": "# 7. 接口\n\n接口是凹语言抽象能力的灵魂。未使用接口的凹语言代码都是纯正的写实派，但是有了接口之后就可以通过鸭子类型的面向对象来达到抽象的目的。本章讲述接口的基本用法。\n"
          }
        }
      }
    }
  }
}